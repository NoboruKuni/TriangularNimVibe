<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>ä¸‰è§’é›£é¡Œ (Triangular Nim)</title>
<style>
/* =========================================
   CSS: éœ“è™¹æš—è‰²é¢¨æ ¼ (Neon Dark Theme)
   ========================================= */
:root {
  --bg-gradient: linear-gradient(135deg, #0f172a, #020617);
  --panel-bg: rgba(255, 255, 255, 0.06);
  --primary: #38bdf8;  /* é’è—è‰² */
  --accent: #facc15;   /* é‡‘é»ƒè‰² */
  --text: #f1f5f9;
  --danger: #ef4444;
  --warn: #f97316;
  --disabled: #475569;
}

body {
  margin: 0;
  font-family: "Noto Sans TC", "Noto Sans JP", "Sarabun", system-ui, sans-serif;
  background: var(--bg-gradient);
  color: var(--text);
  min-height: 100vh;
  overflow-x: hidden;
  touch-action: manipulation;
}

.hidden { display: none !important; }

h1 {
  text-align: center;
  font-size: clamp(1.8rem, 5vw, 2.5rem);
  margin: 25px 0;
  letter-spacing: 2px;
  text-shadow: 0 0 20px rgba(56, 189, 248, 0.4);
  background: linear-gradient(to right, #38bdf8, #818cf8);
  -webkit-background-clip: text;
  color: transparent;
}

/* --- é¸å–®èˆ‡é¢æ¿ --- */
#menu {
  max-width: 550px;
  margin: 0 auto;
  padding: 20px;
}

.panel {
  background: var(--panel-bg);
  padding: 24px;
  border-radius: 18px;
  backdrop-filter: blur(12px);
  border: 1px solid rgba(255,255,255,0.08);
  box-shadow: 0 10px 30px rgba(0,0,0,0.4);
  margin-bottom: 20px;
}

label {
  display: block;
  margin: 16px 0;
  font-size: 1.05rem;
  color: #e2e8f0;
}

select {
  width: 100%;
  margin-top: 8px;
  font-size: 1rem;
  padding: 12px;
  border-radius: 10px;
  border: 1px solid #475569;
  background: rgba(15, 23, 42, 0.9);
  color: white;
  cursor: pointer;
}

/* --- éŠæˆ²ä¸»ç•«é¢ä½ˆå±€ --- */
#game-view {
  display: flex;
  justify-content: center;
  gap: 30px;
  padding: 20px;
  flex-wrap: wrap;
  max-width: 1200px;
  margin: 0 auto;
}

.main-area {
  flex: 1;
  min-width: 320px;
  max-width: 720px;
  display: flex;
  flex-direction: column;
  align-items: center;
  position: relative; 
}

.side-area {
  flex: 0 0 280px;
  display: flex;
  flex-direction: column;
  gap: 15px;
}

@media (max-width: 900px) {
  #game-view { flex-direction: column-reverse; align-items: center; }
  .side-area { width: 100%; max-width: 500px; }
  .main-area { width: 100%; }
}

/* --- Canvas èˆ‡ Banner --- */
.canvas-container {
  position: relative;
  width: 100%;
  display: flex;
  justify-content: center;
}

canvas {
  display: block;
  background: rgba(2, 6, 23, 0.5);
  border-radius: 20px;
  box-shadow: inset 0 0 40px rgba(0,0,0,0.6);
  cursor: pointer;
  width: 100%;
  touch-action: none;
}

/* å‹è² çµæœ Banner */
#result-overlay {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(0.9);
  width: 90%;
  padding: 20px;
  background: rgba(15, 23, 42, 0.95);
  border: 2px solid var(--accent);
  border-radius: 16px;
  text-align: center;
  pointer-events: none; 
  opacity: 0;
  transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  z-index: 10;
  box-shadow: 0 0 50px rgba(250, 204, 21, 0.3);
}

#result-overlay.show {
  opacity: 1;
  transform: translate(-50%, -50%) scale(1);
  pointer-events: auto; 
}

.result-title {
  font-size: 1.8rem;
  font-weight: bold;
  color: var(--accent);
  margin-bottom: 10px;
}
.result-desc {
  font-size: 1.1rem;
  color: #fff;
  line-height: 1.5;
}

/* --- å´é‚Šæ¬„å…ƒä»¶ --- */
.scoreboard { text-align: center; }
.score-item {
  display: flex;
  justify-content: space-between;
  padding: 12px;
  font-size: 1.2rem;
  border-bottom: 1px solid rgba(255,255,255,0.1);
}
.score-item.active {
  color: var(--accent);
  text-shadow: 0 0 10px rgba(250, 204, 21, 0.5);
  font-weight: bold;
  background: rgba(250, 204, 21, 0.05);
}

/* ç¨ç«‹è¦å‰‡é¢æ¿ */
.rule-panel {
  text-align: center;
  border: 1px solid rgba(56, 189, 248, 0.3);
  background: rgba(15, 23, 42, 0.8);
  padding: 15px;
}
.rule-title {
  font-size: 0.9rem;
  color: #94a3b8;
  margin-bottom: 5px;
  text-transform: uppercase;
  letter-spacing: 1px;
}
#rule-hint {
  font-size: 1.2rem;
  font-weight: bold;
  color: var(--primary);
  text-shadow: 0 0 15px rgba(56, 189, 248, 0.4);
  line-height: 1.3;
}

/* ç‹€æ…‹æ–‡å­— */
#status {
  text-align: center;
  font-size: 1.3rem;
  margin-bottom: 10px;
  min-height: 1.5em;
  font-weight: bold;
  color: var(--text);
  text-shadow: 0 0 10px rgba(255,255,255,0.2);
}

.controls {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  justify-content: center;
  margin-top: 15px;
}

/* --- æŒ‰éˆ•æ¨£å¼ --- */
button {
  font-size: 1rem;
  padding: 10px 16px;
  border-radius: 8px;
  border: none;
  background: var(--primary);
  color: #0f172a;
  cursor: pointer;
  font-weight: bold;
  transition: all 0.2s;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}
button:hover:not(:disabled) { filter: brightness(1.15); transform: translateY(-2px); }
button:disabled { background: var(--disabled); color: #94a3b8; cursor: not-allowed; opacity: 0.7; transform: none; }

/* ç¦ç”¨ç‹€æ…‹çš„ç‰¹æ®Šæ¨£å¼ (å¼·åˆ¶ä¸äº’å‹•) */
button.disabled-visual { 
  background: transparent; 
  border: 1px solid #475569; 
  color: #64748b; 
  cursor: not-allowed; 
  pointer-events: none; 
}

/* æ¬¡è¦æŒ‰éˆ• (ç©ºå¿ƒ) */
.btn-secondary { background: transparent; border: 1px solid var(--primary); color: var(--primary); }

/* åˆ‡æ›æŒ‰éˆ• (ç‰¹æ®Šæ¨£å¼) */
.btn-switch { 
  background: rgba(56, 189, 248, 0.1); 
  border: 1px solid var(--primary); 
  color: var(--primary); 
  width: 100%; 
  margin-bottom: 5px;
}
.btn-switch:hover:not(:disabled) {
  background: rgba(56, 189, 248, 0.2);
}

.btn-danger { background: var(--danger); color: white; }
.btn-warn { background: var(--warn); color: #0f172a; }

/* --- èªè¨€åˆ‡æ› --- */
.lang-switch {
  display: flex;
  justify-content: center;
  gap: 8px;
  margin-top: 15px;
  flex-wrap: wrap;
}
.lang-btn {
  background: transparent;
  border: 1px solid #64748b;
  color: #cbd5e1;
  padding: 6px 12px;
  font-size: 0.9rem;
}
.lang-btn.active {
  background: var(--primary);
  color: #0f172a;
  border-color: var(--primary);
  font-weight: bold;
}

/* --- èªªæ˜æ–‡å­— --- */
.rule-box {
  margin-top: 20px;
  max-height: 400px;
  overflow-y: auto;
}
#howto-text {
  font-size: 0.95rem;
  line-height: 1.7;
  color: #cbd5e1;
  text-align: left;
}
#howto-text ol { padding-left: 20px; margin: 0; }
#howto-text li { margin-bottom: 8px; padding-left: 5px; }
#howto-text b { color: var(--accent); }
</style>
</head>
<body>

<div id="menu">
  <h1 data-i18n="title">ä¸‰è§’é›£é¡Œ</h1>
  
  <div class="panel">
    <label>
      <span data-i18n="opponent">å°æ‰‹</span>
      <select id="setting-mode">
        <option value="human" data-i18n="human">é›™äººå°æˆ°</option>
        <option value="ai" data-i18n="ai_normal">å¼· AI</option>
        <option value="weak" data-i18n="ai_easy">å¼± AI</option>
      </select>
    </label>
    
    <label>
      <span data-i18n="rule">è¦å‰‡</span>
      <select id="setting-rule">
        <option value="lose" data-i18n="rule_lose">æ‹¿åˆ°æœ€å¾Œä¸€é¡†è¼¸ (MisÃ¨re)</option>
        <option value="win" data-i18n="rule_win">æ‹¿åˆ°æœ€å¾Œä¸€é¡†è´ (Normal)</option>
      </select>
    </label>
    
    <label>
      <span data-i18n="size">å±¤æ•¸</span>
      <select id="setting-size">
        <option value="4">4</option>
        <option value="5" selected>5</option>
        <option value="6">6</option>
        <option value="7">7</option>
        <option value="8">8</option>
      </select>
    </label>

    <div class="controls">
      <button onclick="game.start()" data-i18n="start" style="width:100%; padding:14px; font-size:1.1rem;">é–‹å§‹éŠæˆ²</button>
    </div>
  </div>

  <div class="lang-switch">
    <button onclick="setLang('zh')" class="lang-btn active">ç¹é«”ä¸­æ–‡</button>
    <button onclick="setLang('en')" class="lang-btn">English</button>
    <button onclick="setLang('ja')" class="lang-btn">æ—¥æœ¬èª</button>
    <button onclick="setLang('th')" class="lang-btn">à¸ à¸²à¸©à¸²à¹„à¸—à¸¢</button>
  </div>

  <div class="panel rule-box">
    <h3 data-i18n="howto_title" style="margin-top:0; color:var(--primary);">ç©æ³•èªªæ˜</h3>
    <div id="howto-text"></div>
  </div>
</div>

<div id="game-view" class="hidden">
  
  <div class="main-area">
    <div id="status"></div>
    
    <div class="canvas-container">
      <canvas id="board"></canvas>
      
      <div id="result-overlay">
        <div class="result-title" id="res-title"></div>
        <div class="result-desc" id="res-desc"></div>
      </div>
    </div>
    
    <div class="controls">
      <button id="btn-confirm" onclick="game.confirmMove()" disabled data-i18n="confirm">ç¢ºèªä¸‹å­</button>
      <button id="btn-cancel" class="btn-secondary" onclick="game.resetSelection()" disabled data-i18n="cancel">å–æ¶ˆé‡é¸</button>
    </div>
  </div>

  <div class="side-area">
    <div class="panel rule-panel">
      <div class="rule-title" data-i18n="rule_title_short">ç•¶å‰è¦å‰‡</div>
      <div id="rule-hint"></div>
    </div>

    <div class="panel scoreboard">
      <h3 data-i18n="scoreboard" style="margin-top:0;">è¨ˆåˆ†æ¿</h3>
      <div id="p1-score-row" class="score-item">
        <span id="p1-name">P1</span>
        <span id="p1-score">0</span>
      </div>
      <div id="p2-score-row" class="score-item">
        <span id="p2-name">P2</span>
        <span id="p2-score">0</span>
      </div>
    </div>

    <div class="panel controls" style="display:flex; flex-direction:column; gap:12px;">
      
      <div>
        <button id="btn-turn" class="btn-switch" onclick="game.toggleTurn()">
          </button>
      </div>

      <div style="display:flex; gap:10px;">
        <button id="btn-undo" class="btn-warn" onclick="game.undo()" disabled style="flex:1;" data-i18n="undo">æ‚”æ£‹</button>
        <button id="btn-surrender" class="btn-danger" onclick="game.surrender()" style="flex:1;" data-i18n="surrender">èªè¼¸</button>
      </div>

      <hr style="width:100%; border:0; border-top:1px solid rgba(255,255,255,0.1); margin: 5px 0;">
      
      <button class="btn-secondary" onclick="game.restart()" data-i18n="restart">å†ä¾†ä¸€å±€</button>
      <button class="btn-secondary" onclick="game.backToMenu()" data-i18n="back">å›é¸å–®</button>
    </div>
  </div>
</div>

<script>
/* =========================================
   1. å¤šèªè¨€ç³»çµ± (I18N)
   ========================================= */
const I18N = {
  zh: {
    title: "ä¸‰è§’é›£é¡Œ",
    opponent: "å°æ‰‹è¨­å®šï¼š", rule: "å‹è² è¦å‰‡ï¼š", size: "æ£‹ç›¤å±¤æ•¸ï¼š",
    size_suffix: "å±¤",
    human: "çœŸäººå°æˆ°", ai_normal: "å¼· AI", ai_easy: "å¼± AI",
    
    // ç©å®¶åç¨±
    name_p1: "ç©å®¶ä¸€", name_p2: "ç©å®¶äºŒ", name_human: "äººé¡",
    name_ai_strong: "å¼· AI", name_ai_weak: "å¼± AI",

    rule_title_short: "ç•¶å‰è¦å‰‡",
    rule_lose: "æ‹¿åˆ°æœ€å¾Œä¸€é¡†çš„äººã€è¼¸ã€‘", rule_win: "æ‹¿åˆ°æœ€å¾Œä¸€é¡†çš„äººã€è´ã€‘",
    start: "é–‹å§‹éŠæˆ²", confirm: "ç¢ºèªä¸‹å­", cancel: "é‡é¸",
    undo: "æ‚”æ£‹ ({n})", surrender: "èªè¼¸",
    restart: "å†ä¾†ä¸€å±€", back: "å›é¸å–®",
    scoreboard: "è¨ˆåˆ†æ¿", howto_title: "è©³ç´°è¦å‰‡",
    status_turn: "è¼ªåˆ°ï¼š{player}",
    status_ai: "ğŸ¤– AI æ­£åœ¨æ€è€ƒ...",
    
    btn_switch_prefix: "åˆ‡æ›å…ˆæ‰‹", 
    
    win_title: "ğŸ‰ éŠæˆ²çµæŸ",
    win_msg: "{winner} ç²å‹ï¼",
    iso_title: "âš ï¸ å­¤ç«‹æ£‹åˆ¤å®š",
    iso_msg: "ç›¤é¢åªå‰©å­¤ç«‹æ£‹å­ (å‰© {c} é¡†)ã€‚\næ ¹æ“šè¦å‰‡ï¼Œç²å‹è€…æ˜¯ï¼š\n{winner}",
    surrender_title: "ğŸ³ï¸ æŠ•é™",
    surrender_msg: "{loser} é¸æ“‡èªè¼¸ã€‚\næ­å–œ {winner} ç²å‹ï¼",

    howto: `
      <ol>
        <li><b>éŠæˆ²ç›®æ¨™</b>ï¼šå…©åç©å®¶è¼ªæµå¾æ£‹ç›¤ä¸Šç§»é™¤æ£‹å­ï¼Œç›´åˆ°æ²’æœ‰æ£‹å­å¯æ‹¿ã€‚</li>
        <li><b>å¦‚ä½•ç§»å‹•</b>ï¼š
           é»æ“Šä¸€é¡†æ£‹å­ä½œç‚º<b>èµ·é»</b>ï¼Œå†é»æ“Šå¦ä¸€é¡†ä½œç‚º<b>çµ‚é»</b>ã€‚å…©é»ä¹‹é–“å¿…é ˆæ˜¯é€£çºŒçš„ç›´ç·šã€‚è‹¥åªæƒ³ç§»é™¤ä¸€é¡†ï¼Œè«‹é»æ“ŠåŒä¸€é¡†æ£‹å­å…©æ¬¡ã€‚</li>
        <li><b>æ•¸é‡é™åˆ¶</b>ï¼šæ¯å›åˆè‡³å°‘æ‹¿ 1 é¡†ï¼Œæœ€å¤šå¯æ‹¿ (å±¤æ•¸ - 1) é¡†ã€‚</li>
        <li><b>å­¤ç«‹æ£‹å­åˆ¤å®š</b>ï¼šç•¶ç›¤é¢ä¸Šæ‰€æœ‰æ£‹å­éƒ½ä¸ç›¸é„°æ™‚ï¼Œç³»çµ±å°‡è‡ªå‹•ä¾è¦å‰‡ç›´æ¥åˆ¤å®šå‹è² ã€‚</li>
        <li><b>è¼”åŠ©åŠŸèƒ½</b>ï¼šæ”¯æ´æ¯å±€ 2 æ¬¡æ‚”æ£‹ï¼›è‹¥å±€é¢ç„¡æœ›å¯ç›´æ¥èªè¼¸ã€‚</li>
      </ol>
    `
  },
  en: {
    title: "Triangular Nim",
    opponent: "Opponent:", rule: "Winning Rule:", size: "Board Size:",
    size_suffix: "Rows",
    human: "PvP (Local)", ai_normal: "Strong AI", ai_easy: "Weak AI",

    name_p1: "Player 1", name_p2: "Player 2", name_human: "Human",
    name_ai_strong: "Strong AI", name_ai_weak: "Weak AI",

    rule_title_short: "Current Rule",
    rule_lose: "Last Taker LOSES", rule_win: "Last Taker WINS",
    start: "Start Game", confirm: "Confirm", cancel: "Reset",
    undo: "Undo ({n})", surrender: "Surrender",
    restart: "Restart", back: "Menu",
    scoreboard: "Scoreboard", howto_title: "How to Play",
    status_turn: "Turn: {player}",
    status_ai: "ğŸ¤– AI is thinking...",
    
    btn_switch_prefix: "Switch Turn Order",

    win_title: "ğŸ‰ Game Over",
    win_msg: "{winner} Wins!",
    iso_title: "âš ï¸ Auto-Resolution",
    iso_msg: "Only isolated stones remain ({c} left).\nBased on the rule, the winner is:\n{winner}",
    surrender_title: "ğŸ³ï¸ Surrender",
    surrender_msg: "{loser} has surrendered.\n{winner} Wins!",

    howto: `
      <ol>
        <li><b>Goal</b>: Players take turns removing stones. The winner is decided by the last stone rule.</li>
        <li><b>Moves</b>: 
           Click a stone for <b>Start</b>, then click another for <b>End</b>. Stones must form a continuous line. Click the same stone twice to pick just one.</li>
        <li><b>Limits</b>: Min 1 stone, Max (Rows - 1) stones per turn.</li>
        <li><b>Isolated Stones</b>: System automatically calculates winner when no moves are possible.</li>
        <li><b>Extras</b>: 2 Undos per game. Surrender button available.</li>
      </ol>
    `
  },
  ja: {
    title: "ä¸‰è§’ãƒ‹ãƒ  (Triangular Nim)",
    opponent: "å¯¾æˆ¦ãƒ¢ãƒ¼ãƒ‰ï¼š", rule: "å‹æ•—ãƒ«ãƒ¼ãƒ«ï¼š", size: "ç›¤é¢ã®ã‚µã‚¤ã‚ºï¼š",
    size_suffix: "æ®µ",
    human: "äºŒäººå¯¾æˆ¦", ai_normal: "å¼·ã„AI", ai_easy: "å¼±ã„AI",

    name_p1: "P1", name_p2: "P2", name_human: "äººé–“",
    name_ai_strong: "å¼·ã„AI", name_ai_weak: "å¼±ã„AI",

    rule_title_short: "ç¾åœ¨ã®ãƒ«ãƒ¼ãƒ«",
    rule_lose: "æœ€å¾Œã®çŸ³ã‚’å–ã‚‹ã¨ã€è² ã‘ã€‘", rule_win: "æœ€å¾Œã®çŸ³ã‚’å–ã‚‹ã¨ã€å‹ã¡ã€‘",
    start: "ã‚²ãƒ¼ãƒ é–‹å§‹", confirm: "æ±ºå®š", cancel: "é¸æŠè§£é™¤",
    undo: "å¾…ã£ãŸ ({n})", surrender: "æŠ•é™",
    restart: "ã‚‚ã†ä¸€åº¦", back: "ãƒ¡ãƒ‹ãƒ¥ãƒ¼",
    scoreboard: "ã‚¹ã‚³ã‚¢", howto_title: "è©³ã—ã„ãƒ«ãƒ¼ãƒ«",
    status_turn: "æ‰‹ç•ªï¼š{player}",
    status_ai: "ğŸ¤– AIè€ƒæ¡ˆä¸­...",
    
    btn_switch_prefix: "å…ˆæ”»äº¤ä»£",

    win_title: "ğŸ‰ å‹è² ã‚ã‚Š",
    win_msg: "å‹è€…ï¼š{winner}",
    iso_title: "âš ï¸ è‡ªå‹•åˆ¤å®š",
    iso_msg: "å­¤ç«‹ã—ãŸçŸ³ã®ã¿æ®‹ã‚Šã¾ã—ãŸï¼ˆæ®‹ã‚Š{c}å€‹ï¼‰ã€‚\nãƒ«ãƒ¼ãƒ«ã«åŸºã¥ãåˆ¤å®šã—ã¾ã™ï¼š\nå‹è€…ï¼š{winner}",
    surrender_title: "ğŸ³ï¸ æŠ•é™",
    surrender_msg: "{loser} ãŒé™å‚ã—ã¾ã—ãŸã€‚\nå‹è€…ï¼š{winner}ï¼",

    howto: `
      <ol>
        <li><b>ç›®çš„</b>ï¼šäº¤äº’ã«çŸ³ã‚’å–ã‚Šåˆã„ã€æœ€å¾Œã®çŸ³ã«é–¢ã™ã‚‹ãƒ«ãƒ¼ãƒ«ã§å‹æ•—ã‚’æ±ºã‚ã¾ã™ã€‚</li>
        <li><b>æ“ä½œæ–¹æ³•</b>ï¼š
           çŸ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦<b>å§‹ç‚¹</b>ã‚’é¸ã³ã€åˆ¥ã®çŸ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦<b>çµ‚ç‚¹</b>ã‚’é¸ã³ã¾ã™ã€‚ç›´ç·šä¸Šã«ä¸¦ã‚“ã çŸ³ã®ã¿é¸æŠå¯èƒ½ã§ã™ã€‚1å€‹ã ã‘å–ã‚‹å ´åˆã¯ã€åŒã˜çŸ³ã‚’2å›ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚</li>
        <li><b>åˆ¶é™</b>ï¼š1ã‚¿ãƒ¼ãƒ³ã«æœ€ä½1å€‹ã€æœ€å¤§ï¼ˆæ®µæ•° - 1ï¼‰å€‹ã¾ã§å–ã‚Œã¾ã™ã€‚</li>
        <li><b>å­¤ç«‹çŸ³ã®åˆ¤å®š</b>ï¼šéš£ã‚Šåˆã†çŸ³ãŒãªããªã£ãŸå ´åˆã€æ®‹ã‚Šã®æ•°ã‹ã‚‰è‡ªå‹•çš„ã«å‹æ•—ã‚’åˆ¤å®šã—ã¾ã™ã€‚</li>
        <li><b>æ©Ÿèƒ½</b>ï¼š1å±€ã«ã¤ã2å›ã¾ã§ã€Œå¾…ã£ãŸã€ãŒã§ãã¾ã™ã€‚æŠ•é™ã‚‚å¯èƒ½ã§ã™ã€‚</li>
      </ol>
    `
  },
  th: {
    title: "à¹€à¸à¸¡à¸à¸¥à¸¢à¸¸à¸—à¸˜à¹Œà¸ªà¸²à¸¡à¹€à¸«à¸¥à¸µà¹ˆà¸¢à¸¡",
    opponent: "à¸„à¸¹à¹ˆà¸•à¹ˆà¸­à¸ªà¸¹à¹‰:", rule: "à¸à¸•à¸´à¸à¸²à¹à¸à¹‰à¸Šà¸™à¸°:", size: "à¸‚à¸™à¸²à¸”à¸à¸£à¸°à¸”à¸²à¸™:",
    size_suffix: "à¸Šà¸±à¹‰à¸™",
    human: "à¹€à¸¥à¹ˆà¸™ 2 à¸„à¸™", ai_normal: "AI à¹€à¸à¹ˆà¸‡", ai_easy: "AI à¸‡à¹ˆà¸²à¸¢",

    name_p1: "à¸œà¸¹à¹‰à¹€à¸¥à¹ˆà¸™ 1", name_p2: "à¸œà¸¹à¹‰à¹€à¸¥à¹ˆà¸™ 2", name_human: "à¸¡à¸™à¸¸à¸©à¸¢à¹Œ",
    name_ai_strong: "AI à¹€à¸à¹ˆà¸‡", name_ai_weak: "AI à¸‡à¹ˆà¸²à¸¢",

    rule_title_short: "à¸à¸•à¸´à¸à¸²",
    rule_lose: "à¸«à¸¢à¸´à¸šà¸„à¸™à¸ªà¸¸à¸”à¸—à¹‰à¸²à¸¢ = ã€à¹à¸à¹‰ã€‘", rule_win: "à¸«à¸¢à¸´à¸šà¸„à¸™à¸ªà¸¸à¸”à¸—à¹‰à¸²à¸¢ = ã€à¸Šà¸™à¸°ã€‘",
    start: "à¹€à¸£à¸´à¹ˆà¸¡à¹€à¸à¸¡", confirm: "à¸¢à¸·à¸™à¸¢à¸±à¸™", cancel: "à¹€à¸¥à¸·à¸­à¸à¹ƒà¸«à¸¡à¹ˆ",
    undo: "à¸¢à¹‰à¸­à¸™à¸à¸¥à¸±à¸š ({n})", surrender: "à¸¢à¸­à¸¡à¹à¸à¹‰",
    restart: "à¹€à¸¥à¹ˆà¸™à¸­à¸µà¸à¸„à¸£à¸±à¹‰à¸‡", back: "à¹€à¸¡à¸™à¸¹à¸«à¸¥à¸±à¸",
    scoreboard: "à¸„à¸°à¹à¸™à¸™", howto_title: "à¸§à¸´à¸˜à¸µà¹€à¸¥à¹ˆà¸™",
    status_turn: "à¸•à¸²à¸‚à¸­à¸‡: {player}",
    status_ai: "ğŸ¤– AI à¸à¸³à¸¥à¸±à¸‡à¸„à¸´à¸”...",
    
    btn_switch_prefix: "à¸ªà¸¥à¸±à¸šà¸¥à¸³à¸”à¸±à¸šà¹€à¸¥à¹ˆà¸™",

    win_title: "ğŸ‰ à¸ˆà¸šà¹€à¸à¸¡",
    win_msg: "à¸œà¸¹à¹‰à¸Šà¸™à¸°à¸„à¸·à¸­: {winner}",
    iso_title: "âš ï¸ à¸•à¸±à¸”à¸ªà¸´à¸™à¸­à¸±à¸•à¹‚à¸™à¸¡à¸±à¸•à¸´",
    iso_msg: "à¹€à¸«à¸¥à¸·à¸­à¹€à¸à¸µà¸¢à¸‡à¸«à¸´à¸™à¸—à¸µà¹ˆà¹à¸¢à¸à¸•à¸±à¸§ ({c} à¸à¹‰à¸­à¸™)\nà¸£à¸°à¸šà¸šà¸„à¸³à¸™à¸§à¸“à¸œà¸¥à¹à¸à¹‰à¸Šà¸™à¸°à¸­à¸±à¸•à¹‚à¸™à¸¡à¸±à¸•à¸´:\nà¸œà¸¹à¹‰à¸Šà¸™à¸°: {winner}",
    surrender_title: "ğŸ³ï¸ à¸¢à¸­à¸¡à¹à¸à¹‰",
    surrender_msg: "{loser} à¸¢à¸­à¸¡à¹à¸à¹‰à¹à¸¥à¹‰à¸§\nà¸¢à¸´à¸™à¸”à¸µà¸”à¹‰à¸§à¸¢ {winner} à¸Šà¸™à¸°!",

    howto: `
      <ol>
        <li><b>à¹€à¸›à¹‰à¸²à¸«à¸¡à¸²à¸¢</b>: à¸œà¸¥à¸±à¸”à¸à¸±à¸™à¸«à¸¢à¸´à¸šà¸«à¸´à¸™à¸­à¸­à¸à¸ˆà¸²à¸à¸à¸£à¸°à¸”à¸²à¸™ à¸ˆà¸™à¸à¸§à¹ˆà¸²à¸ˆà¸°à¸«à¸¡à¸”</li>
        <li><b>à¸§à¸´à¸˜à¸µà¹€à¸”à¸´à¸™à¸«à¸¡à¸²à¸</b>:
           à¸„à¸¥à¸´à¸à¸—à¸µà¹ˆà¸«à¸´à¸™à¹€à¸à¸·à¹ˆà¸­à¹€à¸¥à¸·à¸­à¸ <b>à¸ˆà¸¸à¸”à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™</b> à¹à¸¥à¸°à¸„à¸¥à¸´à¸à¸­à¸µà¸à¸à¹‰à¸­à¸™à¹€à¸à¸·à¹ˆà¸­à¹€à¸¥à¸·à¸­à¸ <b>à¸ˆà¸¸à¸”à¸ªà¸´à¹‰à¸™à¸ªà¸¸à¸”</b> (à¸•à¹‰à¸­à¸‡à¹€à¸›à¹‡à¸™à¹€à¸ªà¹‰à¸™à¸•à¸£à¸‡à¹€à¸”à¸µà¸¢à¸§à¸à¸±à¸™) à¸«à¸²à¸à¸•à¹‰à¸­à¸‡à¸à¸²à¸£à¸«à¸¢à¸´à¸šà¹à¸„à¹ˆ 1 à¸à¹‰à¸­à¸™ à¹ƒà¸«à¹‰à¸„à¸¥à¸´à¸à¸—à¸µà¹ˆà¸«à¸´à¸™à¹€à¸”à¸´à¸¡à¸‹à¹‰à¸³</li>
        <li><b>à¸‚à¹‰à¸­à¸ˆà¸³à¸à¸±à¸”</b>: à¸«à¸¢à¸´à¸šà¹„à¸”à¹‰à¸­à¸¢à¹ˆà¸²à¸‡à¸™à¹‰à¸­à¸¢ 1 à¸à¹‰à¸­à¸™ à¹à¸¥à¸°à¸ªà¸¹à¸‡à¸ªà¸¸à¸” (à¸ˆà¸³à¸™à¸§à¸™à¸Šà¸±à¹‰à¸™ - 1) à¸à¹‰à¸­à¸™à¸•à¹ˆà¸­à¸•à¸²</li>
        <li><b>à¸à¸²à¸£à¸•à¸±à¸”à¸ªà¸´à¸™à¸­à¸±à¸•à¹‚à¸™à¸¡à¸±à¸•à¸´</b>: à¹€à¸¡à¸·à¹ˆà¸­à¹€à¸«à¸¥à¸·à¸­à¹à¸•à¹ˆà¸«à¸´à¸™à¸—à¸µà¹ˆà¹„à¸¡à¹ˆà¸•à¸´à¸”à¸à¸±à¸™ à¸£à¸°à¸šà¸šà¸ˆà¸°à¸„à¸³à¸™à¸§à¸“à¸œà¸¹à¹‰à¸Šà¸™à¸°à¹ƒà¸«à¹‰à¸—à¸±à¸™à¸—à¸µ</li>
        <li><b>à¸•à¸±à¸§à¸Šà¹ˆà¸§à¸¢</b>: à¸ªà¸²à¸¡à¸²à¸£à¸–à¸¢à¹‰à¸­à¸™à¸à¸¥à¸±à¸š (Undo) à¹„à¸”à¹‰ 2 à¸„à¸£à¸±à¹‰à¸‡à¸•à¹ˆà¸­à¹€à¸à¸¡ à¹à¸¥à¸°à¸¡à¸µà¸›à¸¸à¹ˆà¸¡à¸¢à¸­à¸¡à¹à¸à¹‰</li>
      </ol>
    `
  }
};

let currLang = 'zh';

function setLang(lang) {
  currLang = lang;
  
  // æ›´æ–°ä¸€èˆ¬æ–‡å­—
  document.querySelectorAll('[data-i18n]').forEach(el => {
    const key = el.dataset.i18n;
    if (I18N[lang][key]) el.innerHTML = I18N[lang][key];
  });
  
  // æ›´æ–°ä¸‹æ‹‰é¸å–®ä¸­çš„ã€Œå±¤æ•¸ã€æ–‡å­—
  const sizeSelect = document.getElementById('setting-size');
  Array.from(sizeSelect.options).forEach(opt => {
    opt.text = `${opt.value} ${I18N[lang].size_suffix}`;
  });

  // æ›´æ–°è¦å‰‡
  document.getElementById('howto-text').innerHTML = I18N[lang].howto;
  
  // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
  document.querySelectorAll('.lang-btn').forEach(btn => btn.classList.remove('active'));
  const langMap = { 'zh':0, 'en':1, 'ja':2, 'th':3 };
  document.querySelectorAll('.lang-btn')[langMap[lang]].classList.add('active');

  // å¦‚æœéŠæˆ²é€²è¡Œä¸­ï¼Œæ›´æ–°ä»‹é¢æ–‡å­—
  if (game && game.state !== 'menu') game.updateUI();
}

/* =========================================
   2. éŠæˆ²æ ¸å¿ƒé‚è¼¯
   ========================================= */
class TriangularNim {
  constructor() {
    this.canvas = document.getElementById('board');
    this.ctx = this.canvas.getContext('2d');
    
    this.rows = 5;
    this.stones = [];
    this.scores = [0, 0];
    this.state = 'menu'; // menu, playing, locked, gameover
    this.gameStarted = false; // ç´€éŒ„æ˜¯å¦å·²åŸ·è¡Œç¬¬ä¸€æ­¥
    
    this.mode = 'human';
    this.rule = 'lose';
    this.turn = 0; // 0 = Player/P1, 1 = AI/P2
    
    this.selection = { start: null, line: [] };
    this.history = [];
    this.undoCount = 0;
    this.MAX_UNDO = 2;
    this.memo = new Map();

    this.bindEvents();
    window.addEventListener('resize', () => {
       if (this.state !== 'menu') this.resize();
    });
  }

  // --- åˆå§‹åŒ– ---
  start() {
    this.rows = parseInt(document.getElementById('setting-size').value);
    this.mode = document.getElementById('setting-mode').value;
    this.rule = document.getElementById('setting-rule').value;
    this.maxTake = this.rows - 1;

    this.scores = [0, 0];
    document.getElementById('menu').classList.add('hidden');
    document.getElementById('game-view').classList.remove('hidden');

    this.startNewRound();
  }

  startNewRound() {
    this.initStones();
    this.turn = 0;
    this.state = 'playing';
    this.gameStarted = false; // é‡ç½®éŠæˆ²é–‹å§‹ç‹€æ…‹
    this.history = [];
    this.undoCount = 0;
    this.resetSelection();
    this.hideBanner(); 

    requestAnimationFrame(() => {
        this.resize();
        this.updateUI();
    });
  }

  initStones() {
    this.stones = [];
    for (let r = 0; r < this.rows; r++) {
      for (let c = 0; c <= r; c++) {
        this.stones.push({r, c, active: true, x:0, y:0});
      }
    }
  }

  // --- åˆ‡æ›å…ˆå¾Œæ‰‹ ---
  toggleTurn() {
    if (this.gameStarted) return; 

    this.resetSelection();
    this.turn = 1 - this.turn;
    this.updateUI();

    // å¦‚æœåˆ‡æ›å¾Œè¼ªåˆ° AI ä¸”ä¸æ˜¯çœŸäººå°æˆ°
    if (this.mode !== 'human' && this.turn === 1) {
        this.state = 'locked';
        setTimeout(() => this.runAI(), 500);
    }
  }

  // --- ç¹ªåœ– ---
  resize() {
    const container = this.canvas.parentElement;
    if (!container) return;
    
    const w = Math.min(container.clientWidth, 800); 
    const h = Math.max(w * 0.75, 400); 

    const dpr = window.devicePixelRatio || 1;
    this.canvas.width = w * dpr;
    this.canvas.height = h * dpr;
    this.canvas.style.width = w + 'px';
    this.canvas.style.height = h + 'px';
    this.ctx.scale(dpr, dpr);

    this.radius = w / (this.rows * 3 + 2);
    const spacing = this.radius * 2.5;
    const boardH = (this.rows - 1) * (spacing * 0.866);
    const offsetY = (h - boardH) / 2;
    const offsetX = w / 2;

    this.stones.forEach(s => {
      s.x = offsetX + (s.c - s.r / 2) * spacing;
      s.y = offsetY + s.r * (spacing * 0.866);
    });

    this.draw();
  }

  draw() {
    const w = this.canvas.width / (window.devicePixelRatio||1);
    const h = this.canvas.height / (window.devicePixelRatio||1);
    this.ctx.clearRect(0, 0, w, h);

    if (this.selection.line.length > 1) {
      const start = this.selection.line[0];
      const end = this.selection.line[this.selection.line.length - 1];
      this.ctx.beginPath();
      this.ctx.lineCap = 'round';
      this.ctx.lineWidth = this.radius * 1.6;
      this.ctx.strokeStyle = 'rgba(56, 189, 248, 0.25)';
      this.ctx.moveTo(start.x, start.y);
      this.ctx.lineTo(end.x, end.y);
      this.ctx.stroke();
    }

    this.stones.forEach(s => {
      if (!s.active) return;
      
      this.ctx.beginPath();
      this.ctx.arc(s.x, s.y, this.radius, 0, Math.PI*2);
      
      const isSelected = this.selection.line.includes(s);
      const isStart = (s === this.selection.start);

      if (isSelected) {
        this.ctx.fillStyle = '#facc15';
        this.ctx.shadowColor = '#facc15';
        this.ctx.shadowBlur = 15;
      } else {
        this.ctx.fillStyle = '#38bdf8';
        this.ctx.shadowBlur = 0;
      }
      this.ctx.fill();

      if (isStart) {
        this.ctx.lineWidth = 3;
        this.ctx.strokeStyle = '#fff';
        this.ctx.stroke();
      }
    });
  }

  // --- äº’å‹• ---
  bindEvents() {
    const handler = (e) => {
      if (this.state !== 'playing') return;
      if (this.turn === 1 && this.mode !== 'human') return;

      e.preventDefault();
      const rect = this.canvas.getBoundingClientRect();
      const cx = e.touches ? e.touches[0].clientX : e.clientX;
      const cy = e.touches ? e.touches[0].clientY : e.clientY;
      const x = cx - rect.left;
      const y = cy - rect.top;

      const hit = this.stones.find(s => {
        return s.active && Math.hypot(s.x - x, s.y - y) < this.radius * 1.8;
      });

      if (e.type === 'mousedown' || e.type === 'touchstart') {
        if (hit) this.handleInput(hit);
      }
    };
    this.canvas.addEventListener('mousedown', handler);
    this.canvas.addEventListener('touchstart', handler, {passive: false});
  }

  handleInput(stone) {
    if (!this.selection.start) {
      this.selection.start = stone;
      this.selection.line = [stone];
    } else {
      if (stone === this.selection.start) {
        this.selection.line = [stone];
      } else {
        const line = this.calculateLine(this.selection.start, stone);
        if (line) {
          this.selection.line = line;
        } else {
          this.selection.start = stone;
          this.selection.line = [stone];
        }
      }
    }
    this.draw();
    this.updateUI();
  }

  calculateLine(start, end) {
    const dr = end.r - start.r;
    const dc = end.c - start.c;
    let sr=0, sc=0;
    
    if (dr===0) { sr=0; sc = dc>0?1:-1; }
    else if (dc===0) { sr = dr>0?1:-1; sc=0; }
    else if (dr===dc) { sr = dr>0?1:-1; sc = dc>0?1:-1; }
    else return null; 

    const line = [];
    let curr = start;
    while(true) {
      if (!curr.active) return null; 
      line.push(curr);
      if (curr === end) break;
      const nr = curr.r + sr, nc = curr.c + sc;
      const next = this.stones.find(s => s.r===nr && s.c===nc);
      if (!next) return null;
      curr = next;
    }
    if (line.length > this.maxTake) return null;
    return line;
  }

  // --- éŠæˆ²é‚è¼¯ ---
  saveState() {
    const stateSnapshot = {
        stones: this.stones.map(s => ({...s})),
        turn: this.turn
    };
    this.history.push(stateSnapshot);
  }

  confirmMove() {
    if (this.selection.line.length === 0) return;

    this.gameStarted = true;

    this.saveState();
    this.undoCount = 0; 
    this.selection.line.forEach(s => s.active = false);
    this.resetSelection();
    
    if (this.checkWin()) return;

    this.turn = 1 - this.turn;
    
    if (this.checkIsolatedWin()) return;

    this.draw();
    this.updateUI();

    if (this.mode !== 'human' && this.turn === 1) {
      this.state = 'locked';
      setTimeout(() => this.runAI(), 600);
    }
  }

  undo() {
    if (this.history.length === 0 || this.undoCount >= this.MAX_UNDO) return;
    
    if (this.mode !== 'human') {
        if (this.history.length < 2) return;
        this.history.pop(); 
        const prevState = this.history.pop();
        this.restoreState(prevState);
    } else {
        const prevState = this.history.pop();
        this.restoreState(prevState);
    }
    this.undoCount++;
    this.state = 'playing'; 
    this.hideBanner();
    this.resetSelection();
    this.draw();
    this.updateUI();
  }

  restoreState(state) {
      this.stones = state.stones; 
      this.turn = state.turn;
      this.resize();
  }

  surrender() {
    this.state = 'gameover';
    const loser = this.getPlayerName(this.turn);
    const winner = this.getPlayerName(1 - this.turn);
    this.scores[1 - this.turn]++;
    this.updateScoreDisplay();
    this.showBanner('surrender', {loser, winner});
    this.disableControls();
  }

  // --- å‹è² åˆ¤å®š ---
  checkWin() {
    const alive = this.stones.filter(s => s.active).length;
    if (alive > 0) return false;
    
    this.state = 'gameover';
    let winnerIdx = (this.rule === 'lose') ? (1 - this.turn) : this.turn;
    this.scores[winnerIdx]++;
    
    const winner = this.getPlayerName(winnerIdx);
    this.showBanner('win', {winner});
    this.updateScoreDisplay();
    this.disableControls();
    return true;
  }

  checkIsolatedWin() {
    const activeStones = this.stones.filter(s => s.active);
    const dirs = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[-1,-1]];
    
    const hasNeighbors = activeStones.some(s => {
        return dirs.some(d => {
            return this.stones.some(n => n.active && n.r === s.r + d[0] && n.c === s.c + d[1]);
        });
    });

    if (hasNeighbors) return false;

    this.state = 'gameover';
    const count = activeStones.length;
    const lastTakerIdx = (count % 2 === 1) ? this.turn : (1 - this.turn);
    const winnerIdx = (this.rule === 'lose') ? (1 - lastTakerIdx) : lastTakerIdx;

    this.scores[winnerIdx]++;
    const winner = this.getPlayerName(winnerIdx);
    
    this.draw();
    this.updateScoreDisplay();
    
    this.showBanner('iso', {c: count, winner: winner});
    this.disableControls();
    return true;
  }

  // --- Banner é¡¯ç¤ºç³»çµ± ---
  showBanner(type, vars) {
    const overlay = document.getElementById('result-overlay');
    const titleEl = document.getElementById('res-title');
    const descEl = document.getElementById('res-desc');
    
    let titleKey = type + '_title';
    let msgKey = type + '_msg';
    
    let title = I18N[currLang][titleKey];
    let msg = I18N[currLang][msgKey];

    for (let k in vars) {
        msg = msg.replace(`{${k}}`, vars[k]);
    }

    titleEl.innerText = title;
    descEl.innerText = msg;
    
    overlay.classList.add('show');
    document.getElementById('status').innerText = "";
  }

  hideBanner() {
    document.getElementById('result-overlay').classList.remove('show');
  }

  // --- AI (Minimax + Memoization) ---
  getAllMoves(stonesState = null) {
    const moves = [];
    const dirs = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[-1,-1]];
    const currentStones = stonesState || this.stones;
    const actives = currentStones.filter(s => s.active);

    actives.forEach(start => {
      moves.push([start]); 
      dirs.forEach(d => {
        let line = [start];
        let curr = start;
        for (let i = 1; i < this.maxTake; i++) {
          const nr = curr.r + d[0];
          const nc = curr.c + d[1];
          const next = currentStones.find(s => s.active && s.r === nr && s.c === nc);
          if (!next) break;
          curr = next;
          line.push(next);
          moves.push([...line]);
        }
      });
    });
    return moves;
  }

  runAI() {
    if (this.state === 'gameover') return;
    const moves = this.getAllMoves();
    let bestMove = null;

    // --- å¼± AI (éš¨æ©Ÿ) ---
    if (this.mode === 'weak') {
      bestMove = moves[Math.floor(Math.random() * moves.length)];
    } 
    // --- å¼· AI ---
    else {
      const activeCount = this.stones.filter(s => s.active).length;
      
      if (activeCount <= 12) {
        this.memo = new Map();
        this.shuffle(moves);

        for (let move of moves) {
          move.forEach(s => s.active = false);
          const opponentCanWin = this.solveState(); 
          move.forEach(s => s.active = true);

          if (!opponentCanWin) { 
            bestMove = move;
            break; 
          }
        }
        if (!bestMove) bestMove = moves[0];
      } 
      else {
        this.shuffle(moves); 
        for (let m of moves) {
          const remaining = activeCount - m.length;
          if (remaining === 0 && this.rule === 'win') { bestMove = m; break; }
          if (remaining === 1 && this.rule === 'lose') { bestMove = m; break; }
        }
        if (!bestMove) bestMove = moves[0];
      }
    }

    this.selection.line = bestMove;
    this.draw();

    setTimeout(() => {
      this.confirmMove(); 
      if (this.state !== 'gameover') this.state = 'playing';
    }, 600);
  }

  solveState() {
    const stateKey = this.stones.map(s => s.active ? '1' : '0').join('');
    if (this.memo.has(stateKey)) return this.memo.get(stateKey);

    const activeCount = this.stones.filter(s => s.active).length;
    if (activeCount === 0) {
        const result = (this.rule === 'lose'); 
        this.memo.set(stateKey, result);
        return result;
    }

    const moves = this.getAllMoves();
    for (let move of moves) {
        move.forEach(s => s.active = false);
        const opponentCanWin = this.solveState();
        move.forEach(s => s.active = true);

        if (!opponentCanWin) {
            this.memo.set(stateKey, true);
            return true;
        }
    }
    this.memo.set(stateKey, false);
    return false;
  }

  shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  // --- UI Update ---
  updateUI() {
    this.updateScoreDisplay();
    document.getElementById('p1-name').innerText = this.getPlayerName(0);
    document.getElementById('p2-name').innerText = this.getPlayerName(1);
    
    const ruleHintKey = this.rule === 'lose' ? 'rule_lose' : 'rule_win';
    document.getElementById('rule-hint').innerText = I18N[currLang][ruleHintKey];

    if (this.state !== 'gameover') {
        const pName = this.getPlayerName(this.turn);
        const isAi = (this.mode !== 'human' && this.turn === 1);
        const txt = isAi ? I18N[currLang].status_ai 
                         : I18N[currLang].status_turn.replace('{player}', pName);
        
        const el = document.getElementById('status');
        el.innerText = txt;
        el.style.color = isAi ? '#facc15' : '#f8fafc';
    }

    document.getElementById('p1-score-row').classList.toggle('active', this.turn === 0);
    document.getElementById('p2-score-row').classList.toggle('active', this.turn === 1);

    const hasSel = this.selection.line.length > 0;
    const isMyTurn = (this.state === 'playing') && (this.mode === 'human' || this.turn === 0);

    document.getElementById('btn-confirm').disabled = !(hasSel && isMyTurn);
    document.getElementById('btn-cancel').disabled = !(hasSel && isMyTurn);
    
    const undoText = I18N[currLang].undo.replace('{n}', this.MAX_UNDO - this.undoCount);
    const undoBtn = document.getElementById('btn-undo');
    undoBtn.innerText = undoText;
    const canUndo = this.history.length > 0 && this.undoCount < this.MAX_UNDO && isMyTurn;
    undoBtn.disabled = !canUndo;

    document.getElementById('btn-surrender').innerText = I18N[currLang].surrender;
    document.getElementById('btn-surrender').disabled = !isMyTurn;

    // --- æŒ‰éˆ•æ›´æ–° (æŒ‰éˆ•å…§é¡¯ç¤ºæ–‡å­—) ---
    const turnBtn = document.getElementById('btn-turn');
    if (this.gameStarted) {
        turnBtn.classList.add('disabled-visual');
        turnBtn.disabled = true;
    } else {
        turnBtn.classList.remove('disabled-visual');
        turnBtn.disabled = false;
    }
    
    // é¡¯ç¤ºæ–‡å­—ï¼šåˆ‡æ›å…ˆæ‰‹ (ç›®å‰: P1/P2/AI)
    const prefix = I18N[currLang].btn_switch_prefix;
    const currName = this.getPlayerName(this.turn);
    turnBtn.innerText = `${prefix} [${currName}]`;
  }

  disableControls() {
      document.getElementById('btn-confirm').disabled = true;
      document.getElementById('btn-cancel').disabled = true;
      document.getElementById('btn-undo').disabled = true;
      document.getElementById('btn-surrender').disabled = true;
      
      const turnBtn = document.getElementById('btn-turn');
      turnBtn.classList.add('disabled-visual');
      turnBtn.disabled = true;
  }

  updateScoreDisplay() {
    document.getElementById('p1-score').innerText = this.scores[0];
    document.getElementById('p2-score').innerText = this.scores[1];
  }

  getPlayerName(idx) {
    if (idx === 0) {
      return (this.mode !== 'human') ? I18N[currLang].name_human : I18N[currLang].name_p1;
    }
    if (this.mode === 'human') return I18N[currLang].name_p2;
    if (this.mode === 'ai') return I18N[currLang].name_ai_strong;
    if (this.mode === 'weak') return I18N[currLang].name_ai_weak;
  }

  resetSelection() {
    this.selection = { start: null, line: [] };
    this.draw();
    this.updateUI();
  }

  backToMenu() {
    this.state = 'menu';
    document.getElementById('game-view').classList.add('hidden');
    document.getElementById('menu').classList.remove('hidden');
  }

  restart() {
    this.startNewRound();
  }
}

const game = new TriangularNim();
setLang('zh');
</script>

</body>
</html>