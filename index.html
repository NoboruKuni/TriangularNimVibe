<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>ä¸‰è§’é›£é¡Œ (Triangular Nim)</title>
<style>
/* =========================================
   1. CSS è®Šæ•¸èˆ‡å…¨åŸŸè¨­å®š (Global Styles)
   ========================================= */
:root {
  --bg-gradient: linear-gradient(135deg, #0f172a, #020617); /* æ·±è‰²èƒŒæ™¯æ¼¸å±¤ */
  --panel-bg: rgba(255, 255, 255, 0.06); /* åŠé€æ˜é¢æ¿èƒŒæ™¯ */
  --primary: #38bdf8; /* æ¨™æº–ç‰ˆä¸»è‰² (è—) */
  --accent: #facc15;  /* ê°•ì¡°è‰² (é»ƒ) */
  --text: #f1f5f9;    /* ä¸»è¦æ–‡å­—è‰² */
  --danger: #ef4444;  /* å±éšª/èªè¼¸è‰² (ç´…) */
  --warn: #f97316;    /* è­¦å‘Šè‰² (æ©˜) */
  --disabled: #475569;/* ç¦ç”¨è‰² (ç°) */
}

body {
  margin: 0;
  font-family: "Noto Sans TC", "Noto Sans JP", "Sarabun", system-ui, sans-serif;
  background: var(--bg-gradient);
  color: var(--text);
  min-height: 100vh;
  overflow-x: hidden;
  touch-action: manipulation; /* å„ªåŒ–è§¸æ§åæ‡‰ */
}

/* é€šç”¨å·¥å…·é¡ */
.hidden { display: none !important; }

/* æ¨™é¡Œæ¨£å¼ - æ”¯æ´æ¼¸å±¤æ–‡å­— */
h1 {
  text-align: center;
  font-size: clamp(1.8rem, 5vw, 2.5rem);
  margin: 25px 0 15px 0;
  letter-spacing: 2px;
  line-height: 1.2;
  text-shadow: 0 0 20px rgba(56, 189, 248, 0.4);
  background: linear-gradient(to right, #38bdf8, #818cf8);
  -webkit-background-clip: text;
  color: transparent;
  transition: all 0.5s ease;
}

/* å°ˆå®¶æ¨¡å¼æ¨™é¡Œæ¨£å¼ (ç´«è‰²ç³») */
h1.pro-active {
  background: linear-gradient(to right, #c084fc, #facc15);
  -webkit-background-clip: text;
  color: transparent; 
  text-shadow: 0 0 25px rgba(192, 132, 252, 0.5);
}

/* =========================================
   2. é¸å–®èˆ‡é é¢åˆ‡æ› (Menu Slider)
   ========================================= */
#menu-container {
  max-width: 550px;
  margin: 0 auto;
  position: relative;
}

#slider-viewport {
  overflow: hidden;
  width: 100%;
}

#slider-track {
  display: flex;
  width: 200%; /* å…©å€‹é é¢å¯¬åº¦ */
  transition: transform 0.5s cubic-bezier(0.25, 1, 0.5, 1);
}

.menu-page {
  width: 50%;
  padding: 20px;
  box-sizing: border-box;
  opacity: 0.4;
  transition: opacity 0.5s;
}
.menu-page.active-page {
  opacity: 1;
}

/* =========================================
   3. é¢æ¿èˆ‡æ§åˆ¶å…ƒä»¶ (Panels & Controls)
   ========================================= */
.panel {
  background: var(--panel-bg);
  padding: 24px;
  border-radius: 18px;
  backdrop-filter: blur(12px);
  border: 1px solid rgba(255,255,255,0.08);
  box-shadow: 0 10px 30px rgba(0,0,0,0.4);
  margin-bottom: 20px;
}

.panel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}

/* æ¨¡å¼åˆ‡æ›é–‹é—œ (æ¨™æº–/å°ˆå®¶) */
.panel .edition-toggle {
  display: inline-flex;
  width: auto;
  min-width: 160px;
  margin: 0;
  padding: 3px;
  background: rgba(0, 0, 0, 0.3);
  border-radius: 12px;
  border: 1px solid rgba(255, 255, 255, 0.1);
  box-sizing: border-box;
}

.toggle-btn {
  flex: 1;
  text-align: center;
  padding: 4px 10px;
  font-size: 0.85rem;
  border-radius: 8px;
  cursor: pointer;
  color: #94a3b8;
  transition: all 0.2s;
  white-space: nowrap; 
}

.toggle-btn.active {
  background: var(--primary);
  color: #0f172a;
  font-weight: bold;
  box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}

/* å°ˆå®¶æ¨¡å¼çš„ä¸»è‰²èª¿è¦†å¯« */
.pro-theme { --primary: #c084fc; --accent: #facc15; }
.pro-theme .toggle-btn.active { background: var(--accent); color: #4a044e; }

label { display: block; margin: 16px 0; font-size: 1.05rem; color: #e2e8f0; }

select {
  width: 100%;
  margin-top: 8px;
  font-size: 1rem;
  padding: 12px;
  border-radius: 10px;
  border: 1px solid #475569;
  background: rgba(15, 23, 42, 0.9);
  color: white;
  cursor: pointer;
}

/* =========================================
   4. éŠæˆ²ç•«é¢ä½ˆå±€ (Game View Layout)
   ========================================= */
#game-view {
  display: flex;
  justify-content: center;
  gap: 30px;
  padding: 20px;
  flex-wrap: wrap;
  max-width: 1200px;
  margin: 0 auto;
}

.main-area {
  flex: 1;
  min-width: 320px;
  max-width: 720px;
  display: flex;
  flex-direction: column;
  align-items: center;
  position: relative; 
}

.side-area {
  flex: 0 0 280px;
  display: flex;
  flex-direction: column;
  gap: 15px;
}

@media (max-width: 900px) {
  #game-view { flex-direction: column-reverse; align-items: center; }
  .side-area { width: 100%; max-width: 500px; }
  .main-area { width: 100%; }
}

/* =========================================
   5. ç•«å¸ƒèˆ‡äº’å‹•å±¤ (Canvas & Overlay)
   ========================================= */
.canvas-container {
  position: relative;
  width: 100%;
  display: flex;
  justify-content: center;
}

canvas {
  display: block;
  background: rgba(2, 6, 23, 0.5);
  border-radius: 20px;
  box-shadow: inset 0 0 40px rgba(0,0,0,0.6);
  cursor: pointer;
  width: 100%;
  touch-action: none;
}

/* çµç®—ç•«é¢é®ç½© */
#result-overlay {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(0.9);
  width: 90%;
  padding: 20px;
  background: rgba(15, 23, 42, 0.95);
  border: 2px solid var(--accent);
  border-radius: 16px;
  text-align: center;
  pointer-events: none; 
  opacity: 0;
  transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  z-index: 10;
  box-shadow: 0 0 50px rgba(250, 204, 21, 0.3);
}

#result-overlay.show { opacity: 1; transform: translate(-50%, -50%) scale(1); pointer-events: auto; }

.result-title { font-size: 1.8rem; font-weight: bold; color: var(--accent); margin-bottom: 10px; }
.result-desc { font-size: 1.1rem; color: #fff; line-height: 1.5; }

/* =========================================
   6. æŒ‰éˆ•æ¨£å¼ (Buttons)
   ========================================= */
button {
  font-size: 1rem;
  padding: 10px 16px;
  border-radius: 8px;
  border: none;
  background: var(--primary);
  color: #0f172a;
  cursor: pointer;
  font-weight: bold;
  transition: all 0.2s;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}
button:hover:not(:disabled) { filter: brightness(1.15); transform: translateY(-2px); }
button:disabled { background: var(--disabled); color: #94a3b8; cursor: not-allowed; opacity: 0.7; transform: none; }
button.disabled-visual { background: transparent; border: 1px solid #475569; color: #64748b; cursor: not-allowed; pointer-events: none; }

.start-btn { width: 100%; padding: 0 20px; font-size: 1.15rem; height: 52px; display: flex; align-items: center; justify-content: center; line-height: 1; }
.btn-secondary { background: transparent; border: 1px solid var(--primary); color: var(--primary); }
.btn-switch { background: rgba(56, 189, 248, 0.1); border: 1px solid var(--primary); color: var(--primary); width: 100%; margin-bottom: 5px; }
.btn-switch:hover:not(:disabled) { background: rgba(56, 189, 248, 0.2); }
.btn-danger { background: var(--danger); color: white; }
.btn-warn { background: var(--warn); color: #0f172a; }

/* èªè¨€åˆ‡æ›æŒ‰éˆ•å€ */
.lang-switch {
  display: flex;
  justify-content: center;
  gap: 8px;
  margin-top: 30px !important;
  padding-top: 10px;
  flex-wrap: wrap;
  border-top: 1px solid rgba(255,255,255,0.05);
}
.lang-btn {
  background: transparent;
  border: 1px solid #64748b;
  color: #cbd5e1;
  padding: 6px 12px;
  font-size: 0.9rem;
}
.lang-btn.active {
  background: var(--primary);
  color: #0f172a;
  border-color: var(--primary);
  font-weight: bold;
}
.pro-theme .lang-btn { border-color: rgba(192, 132, 252, 0.4); color: #e9d5ff; }
.pro-theme .lang-btn:hover { background: rgba(192, 132, 252, 0.1); }
.pro-theme .lang-btn.active { background: var(--accent); color: #4a044e; border-color: var(--accent); font-weight: bold; box-shadow: 0 0 10px rgba(250, 204, 21, 0.4); }

/* =========================================
   7. è¦å‰‡èªªæ˜èˆ‡è¨ˆåˆ†æ¿ (Rules & Scoreboard)
   ========================================= */
.rule-box {
  margin-top: 15px;
  max-height: none;
  overflow: visible; 
  background: rgba(0, 0, 0, 0.2);
  border-radius: 12px;
  padding: 15px;
  width: 100%;
  box-sizing: border-box;
}
.rule-box h3 { margin-top: 0; margin-bottom: 10px; font-size: 1.1rem; color: var(--primary); border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 8px; }
.howto-content { font-size: 0.95rem; line-height: 1.7; color: #cbd5e1; text-align: left; }
.howto-content ol { padding-left: 20px; margin: 0; }
.howto-content li { margin-bottom: 8px; padding-left: 5px; }
.howto-content b { color: var(--accent); }

/* è‰²å½©å¼·èª¿æ–‡å­— (ç”¨æ–¼é€²éšè¦å‰‡) */
.highlight-orange { color: #f97316; font-weight: bold; text-shadow: 0 0 5px rgba(249, 115, 22, 0.4); }
.highlight-blue { color: #38bdf8; font-weight: bold; text-shadow: 0 0 5px rgba(56, 189, 248, 0.4); }

.scoreboard { text-align: center; }
.score-item { display: flex; justify-content: space-between; padding: 12px; font-size: 1.2rem; border-bottom: 1px solid rgba(255,255,255,0.1); }
.score-item.active { color: var(--accent); text-shadow: 0 0 10px rgba(250, 204, 21, 0.5); font-weight: bold; background: rgba(250, 204, 21, 0.05); }
.rule-panel { text-align: center; border: 1px solid rgba(56, 189, 248, 0.3); background: rgba(15, 23, 42, 0.8); padding: 15px; }
.rule-title { font-size: 0.9rem; color: #94a3b8; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px; }
#rule-hint { font-size: 1.2rem; font-weight: bold; color: var(--primary); text-shadow: 0 0 15px rgba(56, 189, 248, 0.4); line-height: 1.3; }
#status { text-align: center; font-size: 1.3rem; margin-bottom: 10px; min-height: 1.5em; font-weight: bold; color: var(--text); text-shadow: 0 0 10px rgba(255,255,255,0.2); }
</style>
</head>
<body>

<div id="menu-container">
  <h1 id="main-title" data-i18n="title">ä¸‰è§’é›£é¡Œ</h1>
  
  <div id="slider-viewport">
    <div id="slider-track">
      
      <div id="menu-std" class="menu-page active-page">
        <div class="panel">
          <label>
            <div class="panel-header">
              <span data-i18n="opponent">å°æˆ°å½¢å¼</span>
              <div class="edition-toggle">
                <div class="toggle-btn active" onclick="switchEdition('std')" data-i18n="btn_std">æ¨™æº–æ¨¡å¼</div>
                <div class="toggle-btn" onclick="switchEdition('pro')" data-i18n="btn_pro">å°ˆå®¶æ¨¡å¼</div>
              </div>
            </div>
            <select id="setting-mode">
              <option value="human" data-i18n="human">é›™äººå°æˆ°</option>
              <option value="ai" data-i18n="ai_normal">å¼· AI</option>
              <option value="weak" data-i18n="ai_easy">å¼± AI</option>
            </select>
          </label>
          
          <label>
            <span data-i18n="rule">è¦å‰‡</span>
            <select id="setting-rule">
              <option value="lose" data-i18n="rule_lose">æ‹¿åˆ°æœ€å¾Œä¸€é¡†è¼¸ (MisÃ¨re)</option>
              <option value="win" data-i18n="rule_win">æ‹¿åˆ°æœ€å¾Œä¸€é¡†è´ (Normal)</option>
            </select>
          </label>
          
          <label>
            <span data-i18n="size">å±¤æ•¸</span>
            <select id="setting-size">
              <option value="4">4</option>
              <option value="5" selected>5</option>
              <option value="6">6</option>
              <option value="7">7</option>
              <option value="8">8</option>
            </select>
          </label>

          <div class="controls">
            <button class="start-btn" onclick="game.start()" data-i18n="start">é–‹å§‹éŠæˆ²</button>
          </div>

          <div class="lang-switch">
            <button onclick="setLang('zh')" class="lang-btn active">ç¹é«”ä¸­æ–‡</button>
            <button onclick="setLang('en')" class="lang-btn">English</button>
            <button onclick="setLang('ja')" class="lang-btn">æ—¥æœ¬èª</button>
            <button onclick="setLang('th')" class="lang-btn">à¸ à¸²à¸©à¸²à¹„à¸—à¸¢</button>
          </div>
        </div>

        <div class="rule-box">
           <h3 data-i18n="howto_title">ç©æ³•èªªæ˜</h3>
           <div id="howto-text" class="howto-content"></div>
        </div>
      </div>

      <div id="menu-pro" class="menu-page pro-theme">
        <div class="panel">
          <label>
            <div class="panel-header">
              <span data-i18n="opponent">å°æˆ°å½¢å¼</span>
              <div class="edition-toggle">
                <div class="toggle-btn" onclick="switchEdition('std')" data-i18n="btn_std">æ¨™æº–æ¨¡å¼</div>
                <div class="toggle-btn active" onclick="switchEdition('pro')" data-i18n="btn_pro">å°ˆå®¶æ¨¡å¼</div>
              </div>
            </div>
            <select id="setting-mode-pro">
              <option value="human" data-i18n="human">é›™äººå°æˆ°</option>
              <option value="ai" data-i18n="ai_normal">å¼· AI</option>
              <option value="weak" data-i18n="ai_easy">å¼± AI</option>
            </select>
          </label>

          <label>
            <span data-i18n="rule">è¦å‰‡</span>
            <select id="setting-rule-pro">
              <option value="lose" data-i18n="rule_lose">æ‹¿åˆ°æœ€å¾Œä¸€é¡†è¼¸ (MisÃ¨re)</option>
              <option value="win" data-i18n="rule_win">æ‹¿åˆ°æœ€å¾Œä¸€é¡†è´ (Normal)</option>
            </select>
          </label>

          <label>
           <span data-i18n="board_select">æ£‹ç›¤é¸æ“‡</span>
           <select id="setting-board-select">
              <option value="iron_heart">é‹¼éµä¹‹å¿ƒ (Iron Heart)</option>
              <option value="honeycomb">èœ‚å·¢ (Honeycomb)</option>
              <option value="sky_corridor">ç©ºä¸­èµ°å»Š (Sky Corridor)</option>
              <option value="hourglass">æ²™æ¼ (The Hourglass)</option>
              <option value="boomerang">è¿´åŠ›é¢ (Boomerang)</option>
              <option value="donut">ç”œç”œåœˆ (The Donut)</option>
              <option value="bridge">æ–·æ©‹ (Broken Bridge)</option>
              <option value="tetris">ä¿„ç¾…æ–¯æ–¹å¡Š (Tetris)</option>
              <option value="ruins">éºè·¡</option>
            </select>
          </label>

          <div class="controls">
            <button class="start-btn" onclick="game.startPro()" style="background:var(--accent); color:#4a044e;" data-i18n="startChallenge">é–‹å§‹æŒ‘æˆ°</button>
          </div>

          <div class="lang-switch">
            <button onclick="setLang('zh')" class="lang-btn active">ç¹é«”ä¸­æ–‡</button>
            <button onclick="setLang('en')" class="lang-btn">English</button>
            <button onclick="setLang('ja')" class="lang-btn">æ—¥æœ¬èª</button>
            <button onclick="setLang('th')" class="lang-btn">à¸ à¸²à¸©à¸²à¹„à¸—à¸¢</button>
          </div>
        </div>

        <div class="rule-box">
           <h3 data-i18n="howto_title_pro">é€²éšè¦å‰‡</h3>
           <div id="howto-text-pro" class="howto-content"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<div id="game-view" class="hidden">
  <div class="main-area">
    <div id="status"></div>
    <div class="canvas-container">
      <canvas id="board"></canvas>
      <div id="result-overlay">
        <div class="result-title" id="res-title"></div>
        <div class="result-desc" id="res-desc"></div>
      </div>
    </div>
    <div class="controls">
      <button id="btn-confirm" onclick="game.confirmMove()" disabled data-i18n="confirm">ç¢ºèªä¸‹å­</button>
      <button id="btn-cancel" class="btn-secondary" onclick="game.resetSelection()" disabled data-i18n="cancel">å–æ¶ˆé‡é¸</button>
    </div>
  </div>

  <div class="side-area">
    <div class="panel rule-panel">
      <div class="rule-title" data-i18n="rule_title_short">ç•¶å‰è¦å‰‡</div>
      <div id="rule-hint"></div>
    </div>
    <div class="panel scoreboard">
      <h3 data-i18n="scoreboard" style="margin-top:0;">è¨ˆåˆ†æ¿</h3>
      <div id="p1-score-row" class="score-item">
        <span id="p1-name">P1</span>
        <span id="p1-score">0</span>
      </div>
      <div id="p2-score-row" class="score-item">
        <span id="p2-name">P2</span>
        <span id="p2-score">0</span>
      </div>
    </div>
    <div class="panel controls" style="display:flex; flex-direction:column; gap:12px;">
      <div><button id="btn-turn" class="btn-switch" onclick="game.toggleTurn()"></button></div>
      <div style="display:flex; gap:10px;">
        <button id="btn-undo" class="btn-warn" onclick="game.undo()" disabled style="flex:1;" data-i18n="undo">æ‚”æ£‹</button>
        <button id="btn-surrender" class="btn-danger" onclick="game.surrender()" style="flex:1;" data-i18n="surrender">èªè¼¸</button>
      </div>
      <hr style="width:100%; border:0; border-top:1px solid rgba(255,255,255,0.1); margin: 5px 0;">
      <button class="btn-secondary" onclick="game.restart()" data-i18n="restart">å†ä¾†ä¸€å±€</button>
      <button class="btn-secondary" onclick="game.backToMenu()" data-i18n="back">å›é¸å–®</button>
    </div>
  </div>
</div>

<script>
/* =========================================
   1. å¤šèªè¨€ç¿»è­¯è³‡æ–™åº« (I18N)
   ========================================= */
const I18N = {
  zh: {
    title: "ä¸‰è§’é›£é¡Œ", title_pro: "ä¸‰è§’é›£é¡Œ å°ˆå®¶æ¨¡å¼", board_select: "æ£‹ç›¤é¸æ“‡ï¼š", 
    btn_std: "æ¨™æº–æ¨¡å¼", btn_pro: "å°ˆå®¶æ¨¡å¼", opponent: "å°æˆ°å½¢å¼ï¼š", rule: "å‹è² è¦å‰‡ï¼š", size: "æ£‹ç›¤å±¤æ•¸ï¼š",
    size_suffix: "å±¤", human: "çœŸäººå°æˆ°", ai_normal: "å¼· AI", ai_easy: "å¼± AI",
    map_iron: "é‹¼éµä¹‹å¿ƒ", map_honey: "èœ‚å·¢", map_sky: "ç©ºä¸­èµ°å»Š", map_hourglass: "æ²™æ¼",
    map_boomerang: "è¿´åŠ›é¢", map_donut: "ç”œç”œåœˆ", map_bridge: "æ–·æ©‹", map_tetris: "ä¿„ç¾…æ–¯æ–¹å¡Š", map_ruins: "éºè·¡",
    name_p1: "ç©å®¶ä¸€", name_p2: "ç©å®¶äºŒ", name_human: "äººé¡", name_ai_strong: "å¼· AI", name_ai_weak: "å¼± AI",
    rule_title_short: "ç•¶å‰è¦å‰‡", rule_lose: "æ‹¿åˆ°æœ€å¾Œä¸€é¡†çš„äººã€è¼¸ã€‘", rule_win: "æ‹¿åˆ°æœ€å¾Œä¸€é¡†çš„äººã€è´ã€‘",
    start: "é–‹å§‹éŠæˆ²", startChallenge: "é–‹å§‹æŒ‘æˆ°", confirm: "ç¢ºèªä¸‹å­", cancel: "é‡é¸", undo: "æ‚”æ£‹ ({n})", surrender: "èªè¼¸",
    restart: "å†ä¾†ä¸€å±€", back: "å›é¸å–®", scoreboard: "è¨ˆåˆ†æ¿", howto_title: "è©³ç´°è¦å‰‡", howto_title_pro: "é€²éšè¦å‰‡",
    status_turn: "è¼ªåˆ°ï¼š{player}", status_ai: "ğŸ¤– AI æ­£åœ¨æ€è€ƒ...", btn_switch_prefix: "åˆ‡æ›å…ˆæ‰‹", 
    win_title: "ğŸ‰ éŠæˆ²çµæŸ", win_msg: "{winner} ç²å‹ï¼",
    iso_title: "âš ï¸ å­¤ç«‹æ£‹åˆ¤å®š", iso_msg: "ç›¤é¢åªå‰©å­¤ç«‹æ£‹å­ (å‰© {c} é¡†)ã€‚\næ ¹æ“šè¦å‰‡ï¼Œç²å‹è€…æ˜¯ï¼š\n{winner}",
    surrender_title: "ğŸ³ï¸ æŠ•é™", surrender_msg: "{loser} é¸æ“‡èªè¼¸ã€‚\næ­å–œ {winner} ç²å‹ï¼",
    howto: `<ol><li><b>éŠæˆ²ç›®æ¨™</b>ï¼šå…©åç©å®¶è¼ªæµå¾æ£‹ç›¤ä¸Šç§»é™¤æ£‹å­ï¼Œç›´åˆ°æ²’æœ‰æ£‹å­å¯æ‹¿ã€‚</li><li><b>ç§»é™¤æ£‹å­</b>ï¼šé»æ“Šæ£‹å­é¸æ“‡æ¬²ç§»é™¤çš„èµ·é»åŠçµ‚é»ã€‚å…©é»ä¹‹é–“å¿…é ˆæ˜¯é€£çºŒçš„ç›´ç·šï¼Œä¸èƒ½è·³éç©ºæ ¼ã€‚</li><li><b>æ•¸é‡é™åˆ¶</b>ï¼šæ¯å›åˆè‡³å°‘æ‹¿ 1 é¡†ï¼Œæœ€å¤šå¯æ‹¿ (å±¤æ•¸ - 1) é¡†ã€‚</li><li><b>å‹è² åˆ¤å®š</b>ï¼šç•¶ç›¤é¢ä¸Šæ‰€æœ‰æ£‹å­éƒ½ä¸ç›¸é„°æ™‚ï¼Œç³»çµ±å°‡è‡ªå‹•ä¾è¦å‰‡ç›´æ¥åˆ¤å®šå‹è² ã€‚</li><li><b>è¼”åŠ©åŠŸèƒ½</b>ï¼šæ¯å±€éŠæˆ²é–‹å§‹å‰å¯åˆ‡æ›å…ˆæ‰‹ï¼ŒéŠæˆ²ä¸­æœ€å¤šå¯é€£çºŒåš 2 æ¬¡æ‚”æ£‹ã€‚</li></ol>`,
    howto_pro: `<b>ã€äºŒéšæ£‹å­ (Level 2)ã€‘</b><br>ç›¤é¢ä¸Š <span class="highlight-orange">æ©˜è‰²</span> çš„æ£‹å­ç‚ºã€ŒäºŒéšæ£‹å­ã€ã€‚<br>ç¬¬ä¸€æ¬¡æ¶ˆé™¤æ™‚ï¼Œå®ƒæœƒ <b>é™éš</b> è®Šç‚º <span class="highlight-blue">è—è‰²</span> æ£‹å­ï¼Œè€Œä¸æœƒæ¶ˆå¤±ã€‚<br>å†æ¬¡æ¶ˆé™¤è—è‰²æ£‹å­ï¼Œæ‰æœƒå°‡å…¶ç§»å‡ºæ£‹ç›¤ã€‚<br><br><b>ã€å‹è² åˆ¤å®šï¼šæ¬Šé‡ç¸½å’Œã€‘</b><br>ç•¶ç›¤é¢å‰©ä¸‹ä¸é€£çºŒçš„å­¤ç«‹æ£‹å­æ™‚ï¼Œç³»çµ±å°‡ä¾æ“š <b>å‰©é¤˜å¼·åˆ¶æ­¥æ•¸</b> åˆ¤å®šå‹è² ï¼š<br><span class="highlight-blue">è—è‰²</span> = 1 æ­¥ï¼Œ<span class="highlight-orange">æ©˜è‰²</span> = 2 æ­¥ã€‚`
  },
  en: {
    title: "Triangular Nim", title_pro: "Triangular Nim PRO", board_select: "Board Select:",
    btn_std: "Standard Mode", btn_pro: "Pro Mode", opponent: "Match Type:", rule: "Winning Rule:", size: "Board Size:",
    size_suffix: "Rows", human: "PvP (Local)", ai_normal: "Strong AI", ai_easy: "Weak AI",
    map_iron: "Iron Heart", map_honey: "Honeycomb", map_sky: "Sky Corridor", map_hourglass: "The Hourglass",
    map_boomerang: "Boomerang", map_donut: "The Donut", map_bridge: "Broken Bridge", map_tetris: "Tetris", map_ruins: "Ruins",
    name_p1: "Player 1", name_p2: "Player 2", name_human: "Human", name_ai_strong: "Strong AI", name_ai_weak: "Weak AI",
    rule_title_short: "Current Rule", rule_lose: "Last Taker LOSES", rule_win: "Last Taker WINS",
    start: "Start Game", startChallenge: "Start Challenge", confirm: "Confirm", cancel: "Reset", undo: "Undo ({n})", surrender: "Surrender",
    restart: "Restart", back: "Menu", scoreboard: "Scoreboard", howto_title: "How to Play", howto_title_pro: "Advanced Rules",
    status_turn: "Turn: {player}", status_ai: "ğŸ¤– AI is thinking...", btn_switch_prefix: "Switch Turn Order",
    win_title: "ğŸ‰ Game Over", win_msg: "{winner} Wins!",
    iso_title: "âš ï¸ Auto-Resolution", iso_msg: "Only isolated stones remain ({c} left).\nBased on the rule, the winner is:\n{winner}",
    surrender_title: "ğŸ³ï¸ Surrender", surrender_msg: "{loser} has surrendered.\n{winner} Wins!",
    howto: `<ol><li><b>Goal</b>: Two players take turns removing stones until none are left.</li><li><b>Remove</b>: Click to select Start and End stones. The line must be continuous and cannot skip empty spaces.</li><li><b>Limits</b>: Take at least 1 stone, max (Rows - 1) stones per turn.</li><li><b>Winning</b>: System automatically decides the winner when no adjacent stones remain.</li><li><b>Features</b>: Toggle turn order before game; max 2 consecutive undos allowed.</li></ol>`,
    howto_pro: `<b>ã€Level 2 Stonesã€‘</b><br><span class="highlight-orange">Orange</span> stones are "Level 2".<br>Taking them once <b>downgrades</b> them to <span class="highlight-blue">Blue</span> (Level 1) instead of removing them.<br>Taking Blue stones removes them from the board.<br><br><b>ã€Winning Conditionã€‘</b><br>When only isolated stones remain, the winner is decided by <b>Remaining Forced Moves</b>:<br><span class="highlight-blue">Blue</span> = 1 Move, <span class="highlight-orange">Orange</span> = 2 Moves.`
  },
  ja: {
    title: "ä¸‰è§’ãƒ‹ãƒ ", title_pro: "ä¸‰è§’ãƒ‹ãƒ  ãƒ—ãƒ­ãƒ¢ãƒ¼ãƒ‰", board_select: "ç›¤é¢é¸æŠï¼š",
    btn_std: "æ¨™æº–ãƒ¢ãƒ¼ãƒ‰", btn_pro: "ãƒ—ãƒ­ãƒ¢ãƒ¼ãƒ‰", opponent: "å¯¾æˆ¦å½¢å¼ï¼š", rule: "å‹æ•—ãƒ«ãƒ¼ãƒ«ï¼š", size: "ç›¤é¢ã®ã‚µã‚¤ã‚ºï¼š",
    size_suffix: "æ®µ", human: "äºŒäººå¯¾æˆ¦", ai_normal: "å¼·ã„AI", ai_easy: "å¼±ã„AI",
    map_iron: "ã‚¢ã‚¤ã‚¢ãƒ³ãƒãƒ¼ãƒˆ", map_honey: "ãƒãƒ‹ã‚«ãƒ ", map_sky: "å¤©ç©ºã®å›å»Š", map_hourglass: "ç ‚æ™‚è¨ˆ",
    map_boomerang: "ãƒ–ãƒ¼ãƒ¡ãƒ©ãƒ³", map_donut: "ãƒ‰ãƒ¼ãƒŠãƒ„", map_bridge: "å£Šã‚ŒãŸæ©‹", map_tetris: "ãƒ†ãƒˆãƒªã‚¹", map_ruins: "éºè·¡",
    name_p1: "P1", name_p2: "P2", name_human: "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼", name_ai_strong: "å¼·ã„AI", name_ai_weak: "å¼±ã„AI",
    rule_title_short: "ç¾åœ¨ã®ãƒ«ãƒ¼ãƒ«", rule_lose: "æœ€å¾Œã®çŸ³ã‚’å–ã‚‹ã¨ã€è² ã‘ã€‘", rule_win: "æœ€å¾Œã®çŸ³ã‚’å–ã‚‹ã¨ã€å‹ã¡ã€‘",
    start: "ã‚²ãƒ¼ãƒ é–‹å§‹", startChallenge: "æŒ‘æˆ¦é–‹å§‹", confirm: "æ±ºå®š", cancel: "é¸æŠè§£é™¤", undo: "å¾…ã£ãŸ ({n})", surrender: "æŠ•é™",
    restart: "ã‚‚ã†ä¸€åº¦", back: "ãƒ¡ãƒ‹ãƒ¥ãƒ¼", scoreboard: "ã‚¹ã‚³ã‚¢", howto_title: "è©³ã—ã„ãƒ«ãƒ¼ãƒ«", howto_title_pro: "ä¸Šç´šãƒ«ãƒ¼ãƒ«",
    status_turn: "æ‰‹ç•ªï¼š{player}", status_ai: "ğŸ¤– AIè€ƒæ¡ˆä¸­...", btn_switch_prefix: "å…ˆæ”»äº¤ä»£",
    win_title: "ğŸ‰ å‹è² ã‚ã‚Š", win_msg: "å‹è€…ï¼š{winner}",
    iso_title: "âš ï¸ è‡ªå‹•åˆ¤å®š", iso_msg: "å­¤ç«‹ã—ãŸçŸ³ã®ã¿æ®‹ã‚Šã¾ã—ãŸï¼ˆæ®‹ã‚Š{c}å€‹ï¼‰ã€‚\nãƒ«ãƒ¼ãƒ«ã«åŸºã¥ãåˆ¤å®šã—ã¾ã™ï¼š\nå‹è€…ï¼š{winner}",
    surrender_title: "ğŸ³ï¸ æŠ•é™", surrender_msg: "{loser} ãŒé™å‚ã—ã¾ã—ãŸã€‚\nå‹è€…ï¼š{winner}ï¼",
    howto: `<ol><li><b>ç›®çš„</b>ï¼šäº¤äº’ã«çŸ³ã‚’å–ã‚Šåˆã„ã€ãªããªã‚‹ã¾ã§ç¶šã‘ã¾ã™ã€‚</li><li><b>çŸ³ã‚’å–ã‚‹</b>ï¼šå§‹ç‚¹ã¨çµ‚ç‚¹ã‚’é¸æŠã—ã¾ã™ã€‚é–“ã®çŸ³ã¯é€£ç¶šã—ã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã€ç©ºãã‚¹ãƒšãƒ¼ã‚¹ã¯é£›ã°ã›ã¾ã›ã‚“ã€‚</li><li><b>åˆ¶é™</b>ï¼š1å›ã«ã¤ã1å€‹ã‹ã‚‰ï¼ˆæ®µæ•°-1ï¼‰å€‹ã¾ã§å–ã‚Œã¾ã™ã€‚</li><li><b>å‹æ•—åˆ¤å®š</b>ï¼šéš£ã‚Šåˆã†çŸ³ãŒãªããªã‚‹ã¨ã€è‡ªå‹•çš„ã«å‹æ•—ãŒåˆ¤å®šã•ã‚Œã¾ã™ã€‚</li><li><b>æ©Ÿèƒ½</b>ï¼šé–‹å§‹å‰ã«å…ˆæ”»åˆ‡æ›¿å¯ã€‚å¾…ã£ãŸã¯é€£ç¶š2å›ã¾ã§ã€‚</li></ol>`,
    howto_pro: `<b>ã€ãƒ¬ãƒ™ãƒ«2ã®çŸ³ã€‘</b><br><span class="highlight-orange">ã‚ªãƒ¬ãƒ³ã‚¸</span>ã®çŸ³ã¯ã€Œãƒ¬ãƒ™ãƒ«2ã€ã§ã™ã€‚<br>ä¸€åº¦å–ã‚‹ã¨ã€æ¶ˆæ»…ã›ãšã«<span class="highlight-blue">é’è‰²</span>ï¼ˆãƒ¬ãƒ™ãƒ«1ï¼‰ã«<b>ãƒ©ãƒ³ã‚¯ãƒ€ã‚¦ãƒ³</b>ã—ã¾ã™ã€‚<br>é’è‰²ã®çŸ³ã‚’å–ã‚‹ã¨ã€ç›¤ä¸Šã‹ã‚‰å–ã‚Šé™¤ã‹ã‚Œã¾ã™ã€‚<br><br><b>ã€å‹æ•—åˆ¤å®šï¼šé‡ã¿ä»˜ã‘ç·å’Œã€‘</b><br>å­¤ç«‹ã—ãŸçŸ³ã®ã¿ã«ãªã£ãŸå ´åˆã€<b>æ®‹ã‚Šã®å¼·åˆ¶æ‰‹æ•°</b>ã«åŸºã¥ã„ã¦å‹æ•—ã‚’åˆ¤å®šã—ã¾ã™ï¼š<br><span class="highlight-blue">é’</span> = 1æ‰‹ã€<span class="highlight-orange">ã‚ªãƒ¬ãƒ³ã‚¸</span> = 2æ‰‹ã€‚`
  },
  th: {
    title: "à¹€à¸à¸¡à¸à¸¥à¸¢à¸¸à¸—à¸˜à¹Œà¸ªà¸²à¸¡à¹€à¸«à¸¥à¸µà¹ˆà¸¢à¸¡", 
    // ä¿®æ­£é»ï¼šè£œä¸Šæ¨™é¡Œï¼Œè®Šæˆã€ŒéŠæˆ²åç¨± + Proã€
    title_pro: "à¹€à¸à¸¡à¸à¸¥à¸¢à¸¸à¸—à¸˜à¹Œà¸ªà¸²à¸¡à¹€à¸«à¸¥à¸µà¹ˆà¸¢à¸¡ à¹‚à¸›à¸£", 
    board_select: "à¹€à¸¥à¸·à¸­à¸à¸à¸£à¸°à¸”à¸²à¸™:",
    btn_std: "à¹‚à¸«à¸¡à¸”à¸¡à¸²à¸•à¸£à¸à¸²à¸™", btn_pro: "à¹‚à¸«à¸¡à¸”à¹‚à¸›à¸£", opponent: "à¸£à¸¹à¸›à¹à¸šà¸šà¸à¸²à¸£à¹€à¸¥à¹ˆà¸™:", rule: "à¸à¸•à¸´à¸à¸²à¹à¸à¹‰à¸Šà¸™à¸°:", size: "à¸‚à¸™à¸²à¸”à¸à¸£à¸°à¸”à¸²à¸™:",
    size_suffix: "à¸Šà¸±à¹‰à¸™", human: "à¹€à¸¥à¹ˆà¸™ 2 à¸„à¸™", ai_normal: "AI à¹€à¸à¹ˆà¸‡", ai_easy: "AI à¸‡à¹ˆà¸²à¸¢",
    map_iron: "à¸«à¸±à¸§à¹ƒà¸ˆà¹€à¸«à¸¥à¹‡à¸", map_honey: "à¸£à¸±à¸‡à¸œà¸¶à¹‰à¸‡", map_sky: "à¸£à¸°à¹€à¸šà¸µà¸¢à¸‡à¸¥à¸­à¸¢à¸Ÿà¹‰à¸²", map_hourglass: "à¸™à¸²à¸¬à¸´à¸à¸²à¸—à¸£à¸²à¸¢",
    map_boomerang: "à¸šà¸¹à¸¡à¹€à¸¡à¸­à¹à¸£à¸‡", map_donut: "à¹‚à¸”à¸™à¸±à¸—", map_bridge: "à¸ªà¸°à¸à¸²à¸™à¸‚à¸²à¸”", map_tetris: "à¹€à¸•à¸•à¸£à¸´à¸ª", map_ruins: "à¸‹à¸²à¸à¸›à¸£à¸±à¸à¸«à¸±à¸à¸à¸±à¸‡",
    name_p1: "à¸œà¸¹à¹‰à¹€à¸¥à¹ˆà¸™ 1", name_p2: "à¸œà¸¹à¹‰à¹€à¸¥à¹ˆà¸™ 2", name_human: "à¸¡à¸™à¸¸à¸©à¸¢à¹Œ", name_ai_strong: "AI à¹€à¸à¹ˆà¸‡", name_ai_weak: "AI à¸‡à¹ˆà¸²à¸¢",
    rule_title_short: "à¸à¸•à¸´à¸à¸²", rule_lose: "à¸«à¸¢à¸´à¸šà¸„à¸™à¸ªà¸¸à¸”à¸—à¹‰à¸²à¸¢ = ã€à¹à¸à¹‰ã€‘", rule_win: "à¸«à¸¢à¸´à¸šà¸„à¸™à¸ªà¸¸à¸”à¸—à¹‰à¸²à¸¢ = ã€à¸Šà¸™à¸°ã€‘",
    start: "à¹€à¸£à¸´à¹ˆà¸¡à¹€à¸à¸¡", startChallenge: "à¹€à¸£à¸´à¹ˆà¸¡à¸—à¹‰à¸²à¸—à¸²à¸¢", confirm: "à¸¢à¸·à¸™à¸¢à¸±à¸™", cancel: "à¹€à¸¥à¸·à¸­à¸à¹ƒà¸«à¸¡à¹ˆ", undo: "à¸¢à¹‰à¸­à¸™à¸à¸¥à¸±à¸š ({n})", surrender: "à¸¢à¸­à¸¡à¹à¸à¹‰",
    restart: "à¹€à¸¥à¹ˆà¸™à¸­à¸µà¸à¸„à¸£à¸±à¹‰à¸‡", back: "à¹€à¸¡à¸™à¸¹à¸«à¸¥à¸±à¸", scoreboard: "à¸„à¸°à¹à¸™à¸™", howto_title: "à¸§à¸´à¸˜à¸µà¹€à¸¥à¹ˆà¸™", howto_title_pro: "à¸à¸•à¸´à¸à¸²à¸à¸´à¹€à¸¨à¸©",
    status_turn: "à¸•à¸²à¸‚à¸­à¸‡: {player}", status_ai: "ğŸ¤– AI à¸à¸³à¸¥à¸±à¸‡à¸„à¸´à¸”...", btn_switch_prefix: "à¸ªà¸¥à¸±à¸šà¸¥à¸³à¸”à¸±à¸šà¹€à¸¥à¹ˆà¸™",
    win_title: "ğŸ‰ à¸ˆà¸šà¹€à¸à¸¡", win_msg: "à¸œà¸¹à¹‰à¸Šà¸™à¸°à¸„à¸·à¸­: {winner}",
    iso_title: "âš ï¸ à¸•à¸±à¸”à¸ªà¸´à¸™à¸­à¸±à¸•à¹‚à¸™à¸¡à¸±à¸•à¸´", iso_msg: "à¹€à¸«à¸¥à¸·à¸­à¹€à¸à¸µà¸¢à¸‡à¸«à¸´à¸™à¸—à¸µà¹ˆà¹à¸¢à¸à¸•à¸±à¸§ ({c} à¸à¹‰à¸­à¸™)\nà¸£à¸°à¸šà¸šà¸„à¸³à¸™à¸§à¸“à¸œà¸¥à¹à¸à¹‰à¸Šà¸™à¸°à¸­à¸±à¸•à¹‚à¸™à¸¡à¸±à¸•à¸´:\nà¸œà¸¹à¹‰à¸Šà¸™à¸°: {winner}",
    surrender_title: "ğŸ³ï¸ à¸¢à¸­à¸¡à¹à¸à¹‰", surrender_msg: "{loser} à¸¢à¸­à¸¡à¹à¸à¹‰à¹à¸¥à¹‰à¸§\nà¸¢à¸´à¸™à¸”à¸µà¸”à¹‰à¸§à¸¢ {winner} à¸Šà¸™à¸°!",
    howto: `<ol><li><b>à¹€à¸›à¹‰à¸²à¸«à¸¡à¸²à¸¢</b>: à¸œà¸¥à¸±à¸”à¸à¸±à¸™à¸«à¸¢à¸´à¸šà¸«à¸´à¸™à¸ˆà¸™à¸«à¸¡à¸”à¸à¸£à¸°à¸”à¸²à¸™</li><li><b>à¸§à¸´à¸˜à¸µà¸«à¸¢à¸´à¸š</b>: à¹€à¸¥à¸·à¸­à¸à¸ˆà¸¸à¸”à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™à¹à¸¥à¸°à¸ªà¸´à¹‰à¸™à¸ªà¸¸à¸” à¸•à¹‰à¸­à¸‡à¹€à¸›à¹‡à¸™à¹€à¸ªà¹‰à¸™à¸•à¸£à¸‡à¸•à¹ˆà¸­à¹€à¸™à¸·à¹ˆà¸­à¸‡ à¸«à¹‰à¸²à¸¡à¸‚à¹‰à¸²à¸¡à¸Šà¹ˆà¸­à¸‡à¸§à¹ˆà¸²à¸‡</li><li><b>à¸‚à¹‰à¸­à¸ˆà¸³à¸à¸±à¸”</b>: à¸«à¸¢à¸´à¸š 1 à¸–à¸¶à¸‡ (à¸ˆà¸³à¸™à¸§à¸™à¸Šà¸±à¹‰à¸™ - 1) à¸à¹‰à¸­à¸™à¸•à¹ˆà¸­à¸•à¸²</li><li><b>à¸•à¸±à¸”à¸ªà¸´à¸™</b>: à¸£à¸°à¸šà¸šà¸•à¸±à¸”à¸ªà¸´à¸™à¸œà¸¹à¹‰à¸Šà¸™à¸°à¸—à¸±à¸™à¸—à¸µà¹€à¸¡à¸·à¹ˆà¸­à¹„à¸¡à¹ˆà¸¡à¸µà¸«à¸´à¸™à¸•à¸´à¸”à¸à¸±à¸™</li><li><b>à¸Ÿà¸µà¹€à¸ˆà¸­à¸£à¹Œ</b>: à¸ªà¸¥à¸±à¸šà¸„à¸™à¹€à¸£à¸´à¹ˆà¸¡à¸à¹ˆà¸­à¸™à¹„à¸”à¹‰ à¹à¸¥à¸°à¸¢à¹‰à¸­à¸™à¸à¸¥à¸±à¸šà¹„à¸”à¹‰ 2 à¸„à¸£à¸±à¹‰à¸‡</li></ol>`,
    howto_pro: `<b>ã€à¸«à¸´à¸™à¸£à¸°à¸”à¸±à¸š 2ã€‘</b><br>à¸«à¸´à¸™à¸ªà¸µ<span class="highlight-orange">à¸ªà¹‰à¸¡</span> à¸„à¸·à¸­ "à¸«à¸´à¸™à¸£à¸°à¸”à¸±à¸š 2"<br>à¹€à¸¡à¸·à¹ˆà¸­à¸–à¸¹à¸à¸«à¸¢à¸´à¸šà¸„à¸£à¸±à¹‰à¸‡à¹à¸£à¸ à¸ˆà¸°<b>à¸¥à¸”à¸£à¸°à¸”à¸±à¸š</b>à¸à¸¥à¸²à¸¢à¹€à¸›à¹‡à¸™à¸ªà¸µ<span class="highlight-blue">à¸Ÿà¹‰à¸²</span> (à¹„à¸¡à¹ˆà¸«à¸²à¸¢à¹„à¸›)<br>à¸•à¹‰à¸­à¸‡à¸«à¸¢à¸´à¸šà¸•à¸­à¸™à¹€à¸›à¹‡à¸™à¸ªà¸µà¸Ÿà¹‰à¸²à¸­à¸µà¸à¸„à¸£à¸±à¹‰à¸‡à¸–à¸¶à¸‡à¸ˆà¸°à¸­à¸­à¸à¸ˆà¸²à¸à¸à¸£à¸°à¸”à¸²à¸™<br><br><b>ã€à¸à¸²à¸£à¸•à¸±à¸”à¸ªà¸´à¸™à¹à¸à¹‰à¸Šà¸™à¸°ã€‘</b><br>à¹€à¸¡à¸·à¹ˆà¸­à¹€à¸«à¸¥à¸·à¸­à¹à¸•à¹ˆà¸«à¸´à¸™à¸—à¸µà¹ˆà¹à¸¢à¸à¸•à¸±à¸§ à¸£à¸°à¸šà¸šà¸ˆà¸°à¸•à¸±à¸”à¸ªà¸´à¸™à¸ˆà¸²à¸ <b>à¸ˆà¸³à¸™à¸§à¸™à¸•à¸²à¹€à¸”à¸´à¸™à¸—à¸µà¹ˆà¸šà¸±à¸‡à¸„à¸±à¸šà¹€à¸«à¸¥à¸·à¸­à¸­à¸¢à¸¹à¹ˆ</b>:<br>à¸ªà¸µ<span class="highlight-blue">à¸Ÿà¹‰à¸²</span> = 1 à¸•à¸², à¸ªà¸µ<span class="highlight-orange">à¸ªà¹‰à¸¡</span> = 2 à¸•à¸²`
  }
};

let currLang = 'zh';

/* =========================================
   2. èªè¨€åˆ‡æ›èˆ‡ UI æ›´æ–°å‡½å¼
   ========================================= */
function setLang(lang) {
  currLang = lang;
  // æ›´æ–°æ‰€æœ‰å¸¶æœ‰ data-i18n å±¬æ€§çš„æ–‡å­—
  document.querySelectorAll('[data-i18n]').forEach(el => {
    const key = el.dataset.i18n;
    if (I18N[lang][key]) el.innerHTML = I18N[lang][key];
  });
  
  // æ›´æ–°ä¸‹æ‹‰é¸å–®é¸é … (æ£‹ç›¤é¸æ“‡)
  const boardSelect = document.getElementById('setting-board-select');
  if (boardSelect) {
      const keys = ['map_iron', 'map_honey', 'map_sky', 'map_hourglass', 'map_boomerang', 'map_donut', 'map_bridge', 'map_tetris', 'map_ruins'];
      Array.from(boardSelect.options).forEach((opt, idx) => {
          if (keys[idx] && I18N[lang][keys[idx]]) opt.text = I18N[lang][keys[idx]];
      });
  }

  // æ›´æ–°ä¸‹æ‹‰é¸å–®é¸é … (å°ºå¯¸)
  const sizeSelect = document.getElementById('setting-size');
  if(sizeSelect) {
      Array.from(sizeSelect.options).forEach(opt => opt.text = `${opt.value} ${I18N[lang].size_suffix}`);
  }

  // æ›´æ–°è¦å‰‡èªªæ˜ HTML
  const stdRule = document.getElementById('howto-text');
  if (stdRule) stdRule.innerHTML = I18N[lang].howto;
  const proRule = document.getElementById('howto-text-pro');
  if (proRule) proRule.innerHTML = I18N[lang].howto_pro;
  
  // æ›´æ–°èªè¨€æŒ‰éˆ•ç‹€æ…‹
  document.querySelectorAll('.lang-btn').forEach(btn => btn.classList.remove('active'));
  const langMap = { 'zh':0, 'en':1, 'ja':2, 'th':3 };
  document.querySelectorAll('.lang-switch').forEach(container => {
      const btns = container.querySelectorAll('.lang-btn');
      if (btns[langMap[lang]]) btns[langMap[lang]].classList.add('active');
  });

  // è‹¥éŠæˆ²æ­£åœ¨é€²è¡Œä¸­ï¼ŒåŒæ­¥æ›´æ–°éŠæˆ²å…§æ–‡å­—
  if (game && game.state !== 'menu') game.updateUI();
}

/* =========================================
   3. æ¨™æº–æ¨¡å¼/å°ˆå®¶æ¨¡å¼ åˆ‡æ›é‚è¼¯
   ========================================= */
function switchEdition(edition) {
  const track = document.getElementById('slider-track');
  const pageStd = document.getElementById('menu-std');
  const pagePro = document.getElementById('menu-pro');
  const titleEl = document.getElementById('main-title');
  const allToggles = document.querySelectorAll('.edition-toggle');

  if (edition === 'std') {
    // åˆ‡æ›åˆ°æ¨™æº–æ¨¡å¼
    track.style.transform = 'translateX(0)';
    pageStd.classList.add('active-page'); pagePro.classList.remove('active-page');
    titleEl.classList.remove('pro-active'); titleEl.dataset.i18n = 'title';
    allToggles.forEach(toggle => {
      const btns = toggle.querySelectorAll('.toggle-btn');
      if(btns.length >= 2) { btns[0].classList.add('active'); btns[1].classList.remove('active'); }
    });
  } else {
    // åˆ‡æ›åˆ°å°ˆå®¶æ¨¡å¼
    track.style.transform = 'translateX(-50%)';
    pagePro.classList.add('active-page'); pageStd.classList.remove('active-page');
    titleEl.classList.add('pro-active'); titleEl.dataset.i18n = 'title_pro';
    allToggles.forEach(toggle => {
      const btns = toggle.querySelectorAll('.toggle-btn');
      if(btns.length >= 2) { btns[0].classList.remove('active'); btns[1].classList.add('active'); }
    });
  }
  setLang(currLang); // é‡æ–°å¥—ç”¨èªè¨€ä»¥æ›´æ–°æ¨™é¡Œ
}

/* =========================================
   4. éŠæˆ²æ ¸å¿ƒé‚è¼¯é¡åˆ¥ (Game Class)
   ========================================= */
class TriangularNim {
  constructor() {
    this.canvas = document.getElementById('board');
    this.ctx = this.canvas.getContext('2d');
    this.rows = 5;
    this.stones = [];
    this.scores = [0, 0];
    this.state = 'menu';
    this.gameStarted = false;
    this.mode = 'human';
    this.rule = 'lose';
    this.turn = 0;
    this.selection = { start: null, line: [] };
    this.history = [];
    this.undoCount = 0;
    this.MAX_UNDO = 2;
    this.memo = new Map();
    this.bindEvents();
    // è¦–çª—ç¸®æ”¾æ™‚é‡æ–°è¨ˆç®—ç•«å¸ƒ
    window.addEventListener('resize', () => { if (this.state !== 'menu') this.resize(); });
  }

  // --- éŠæˆ²åˆå§‹åŒ–ç›¸é—œ ---
  start() {
    this.isProMode = false; 
    this.rows = parseInt(document.getElementById('setting-size').value);
    this.mode = document.getElementById('setting-mode').value;
    this.rule = document.getElementById('setting-rule').value;
    this.maxTake = this.rows - 1;
    this.scores = [0, 0];
    document.getElementById('menu-container').classList.add('hidden');
    document.getElementById('game-view').classList.remove('hidden');
    this.startNewRound();
  }

  startPro() {
    this.isProMode = true;
    this.mode = document.getElementById('setting-mode-pro').value;
    this.rule = document.getElementById('setting-rule-pro').value;
    this.boardType = document.getElementById('setting-board-select').value;

    // ä¾æ“šä¸åŒåœ°åœ–è¨­å®šå±¤æ•¸
    if (this.boardType === 'iron_heart') this.rows = 5;
    else if (['boomerang', 'donut'].includes(this.boardType)) this.rows = 6;
    else this.rows = 7; 

    this.maxTake = this.rows - 1; 
    this.scores = [0, 0];
    document.getElementById('menu-container').classList.add('hidden');
    document.getElementById('game-view').classList.remove('hidden');
    this.startNewRound();
  }

  startNewRound() {
    this.initStones();
    this.turn = 0;
    this.state = 'playing';
    this.gameStarted = false; 
    this.history = [];
    this.undoCount = 0;
    this.resetSelection();
    this.hideBanner(); 
    requestAnimationFrame(() => { this.resize(); this.updateUI(); });
  }

  initStones() {
    this.stones = [];
    // å»ºç«‹åŸºæœ¬çš„ä¸‰è§’å½¢æ’åˆ—
    for (let r = 0; r < this.rows; r++) {
      for (let c = 0; c <= r; c++) {
        this.stones.push({r, c, active: true, level: 1, x:0, y:0, flash: 0});
      }
    }

    // å°ˆå®¶æ¨¡å¼çš„åœ°åœ–é…ç½®é‚è¼¯
    if (this.isProMode) {
       if (this.boardType === 'iron_heart') {
          this.applyMapConfig([[2,1], [3,1], [3,2]], 2);
       }
       else if (['honeycomb', 'sky_corridor', 'bridge'].includes(this.boardType)) {
          // å…ˆæŒ–æ‰ä¸€äº›æ´
          this.removeStone(0,0);
          this.removeStone(1,0); this.removeStone(1,1);
          this.removeStone(5,0); this.removeStone(6,0); this.removeStone(6,1);
          this.removeStone(5,5); this.removeStone(6,5); this.removeStone(6,6);

          if (this.boardType === 'honeycomb') {
              this.applyMapConfig([[4,2], [3,1], [3,2], [4,1], [4,3], [5,2], [5,3]], 2);
          } else if (this.boardType === 'sky_corridor') {
              const h_bridge = [[4,0], [4,1], [4,2], [4,3], [4,4]];
              const v_pillar = [[3,1], [3,2], [5,2], [5,3], [2,0], [2,2], [6,2], [6,4]];
              this.applyMapConfig([...h_bridge, ...v_pillar], 2);
          } else if (this.boardType === 'bridge') { 
              this.removeStone(4,0); this.removeStone(4,1); this.removeStone(4,3); this.removeStone(4,4);
              this.stones.forEach(s => { if (s.active && s.c <= 2) s.level = 2; });
              const bridge = this.stones.find(s => s.r===4 && s.c===2);
              if(bridge) bridge.level = 1; 
          }
       }
       else if (this.boardType === 'hourglass') {
          this.removeStone(3,0); this.removeStone(3,3); 
          this.removeStone(4,0); this.removeStone(4,4);
          this.removeStone(5,0); this.removeStone(6,0); this.removeStone(6,1); 
          this.removeStone(5,5); this.removeStone(6,5); this.removeStone(6,6); 
          this.applyMapConfig([[0,0], [2,1], [4,2], [5,2], [5,3], [6,2], [6,3], [6,4]], 2);
       }
       else if (this.boardType === 'boomerang') {
          for(let r=2; r<6; r++) { for(let c=2; c<r-1; c++) this.removeStone(r, c); }
          this.applyMapConfig([[0,0], [1,0], [1,1], [5,0], [5,1], [5,4], [5,5]], 2);
       }
       else if (this.boardType === 'donut') {
          this.removeStone(0,0); 
          this.removeStone(5,0); this.removeStone(5,5); 
          this.removeStone(3,1); this.removeStone(3,2); this.removeStone(4,2);
          const innerRing = [[2,0], [2,1], [2,2], [3,0], [3,3], [4,1], [4,3], [5,2], [5,3]];
          this.applyMapConfig(innerRing, 2);
       }
       else if (this.boardType === 'tetris') {
          this.removeStone(0,0); this.removeStone(6,0); this.removeStone(6,5); this.removeStone(3,0); this.removeStone(3,3);
          const shapeI = [[1,0], [2,0], [2,1], [2,2], [3,2]];
          const shapeO = [[4,0], [5,0], [5,1], [6,1]];
          const shapeL = [[4,4], [5,4], [6,3], [6,4]];
          this.applyMapConfig([...shapeI, ...shapeO, ...shapeL], 2);
       }
       else if (this.boardType === 'ruins') {
          this.removeStone(0,0); this.removeStone(1,0); this.removeStone(2,0);
          this.removeStone(6,5); this.removeStone(6,6); this.removeStone(5,5);
          this.removeStone(3,2); this.removeStone(4,2);
          const pillar = [[2,1], [3,1], [4,1], [5,1]]; 
          const wall = [[3,3], [4,3], [4,4]]; 
          const debris = [[1,1], [6,2], [5,0], [6,4]]; 
          this.applyMapConfig([...pillar, ...wall, ...debris], 2);
       }
    }
  }

  // Helper: ç§»é™¤æ£‹å­ (æ¨™è¨˜ç‚ºä¸æ´»èº)
  removeStone(r, c) { const s = this.stones.find(st => st.r === r && st.c === c); if (s) s.active = false; }
  // Helper: è¨­å®šæ£‹å­ç­‰ç´š (Lv2 ç‚ºæ©˜è‰²)
  applyMapConfig(targets, lvl) { targets.forEach(([tr, tc]) => { const s = this.stones.find(st => st.r === tr && st.c === tc); if (s) s.level = lvl; }); }

  // --- ç•«å¸ƒç¹ªè£½èˆ‡éŸ¿æ‡‰å¼ ---
  resize() {
    const container = this.canvas.parentElement; if (!container) return;
    const w = Math.min(container.clientWidth, 800); const h = Math.max(w * 0.75, 400); 
    const dpr = window.devicePixelRatio || 1;
    this.canvas.width = w * dpr; this.canvas.height = h * dpr;
    this.canvas.style.width = w + 'px'; this.canvas.style.height = h + 'px';
    this.ctx.scale(dpr, dpr);
    this.radius = w / (this.rows * 3 + 2);
    const spacing = this.radius * 2.5;
    const boardH = (this.rows - 1) * (spacing * 0.866);
    const offsetY = (h - boardH) / 2; const offsetX = w / 2;
    this.stones.forEach(s => { s.x = offsetX + (s.c - s.r / 2) * spacing; s.y = offsetY + s.r * (spacing * 0.866); });
    this.draw();
  }

  draw() {
    const w = this.canvas.width / (window.devicePixelRatio||1); const h = this.canvas.height / (window.devicePixelRatio||1);
    this.ctx.clearRect(0, 0, w, h);
    // ç¹ªè£½é¸å–ç·š
    if (this.selection.line.length > 1) {
      const start = this.selection.line[0]; const end = this.selection.line[this.selection.line.length - 1];
      this.ctx.beginPath(); this.ctx.lineCap = 'round'; this.ctx.lineWidth = this.radius * 1.6;
      this.ctx.strokeStyle = 'rgba(56, 189, 248, 0.25)'; this.ctx.moveTo(start.x, start.y); this.ctx.lineTo(end.x, end.y); this.ctx.stroke();
    }
    // ç¹ªè£½æ£‹å­
    this.stones.forEach(s => {
      if (!s.active) return;
      this.ctx.beginPath(); this.ctx.arc(s.x, s.y, this.radius, 0, Math.PI*2);
      const isSelected = this.selection.line.includes(s); const isStart = (s === this.selection.start);
      // é¡è‰²é‚è¼¯: Lv2(æ©˜è‰²), Lv1(è—è‰²)
      if (s.level === 2) { this.ctx.fillStyle = isSelected ? '#fed7aa' : '#f97316'; this.ctx.shadowColor = '#f97316'; }
      else { this.ctx.fillStyle = isSelected ? '#facc15' : '#38bdf8'; this.ctx.shadowColor = '#38bdf8'; }
      this.ctx.shadowBlur = isSelected ? 20 : 0; this.ctx.fill();
      // ç¹ªè£½ Lv2 çš„æ ¸å¿ƒäº®é»
      if (s.level === 2) { this.ctx.beginPath(); this.ctx.arc(s.x, s.y, this.radius * 0.4, 0, Math.PI*2); this.ctx.fillStyle = 'rgba(255,255,255,0.3)'; this.ctx.fill(); }
      // é–ƒçˆæ•ˆæœ
      if (s.flash > 0) { this.ctx.fillStyle = `rgba(255, 255, 255, ${s.flash / 20})`; this.ctx.fill(); s.flash--; requestAnimationFrame(() => this.draw()); }
      // èµ·é»æ¨™è¨˜
      if (isStart) { this.ctx.lineWidth = 3; this.ctx.strokeStyle = '#fff'; this.ctx.stroke(); }
    });
  }

  // --- è¼¸å…¥äº‹ä»¶è™•ç† ---
  bindEvents() {
    const handler = (e) => {
      if (this.state !== 'playing') return; if (this.turn === 1 && this.mode !== 'human') return;
      e.preventDefault();
      const rect = this.canvas.getBoundingClientRect();
      const cx = e.touches ? e.touches[0].clientX : e.clientX; const cy = e.touches ? e.touches[0].clientY : e.clientY;
      const hit = this.stones.find(s => s.active && Math.hypot(s.x - (cx - rect.left), s.y - (cy - rect.top)) < this.radius * 1.8);
      if ((e.type === 'mousedown' || e.type === 'touchstart') && hit) this.handleInput(hit);
    };
    this.canvas.addEventListener('mousedown', handler);
    this.canvas.addEventListener('touchstart', handler, {passive: false});
  }

  handleInput(stone) {
    if (!this.selection.start) { this.selection.start = stone; this.selection.line = [stone]; } 
    else {
      if (stone === this.selection.start) this.selection.line = [stone];
      else {
        const line = this.calculateLine(this.selection.start, stone);
        if (line) this.selection.line = line; else { this.selection.start = stone; this.selection.line = [stone]; }
      }
    }
    this.draw(); this.updateUI();
  }

  // è¨ˆç®—æ˜¯å¦é€£ç·šæˆåŠŸ
  calculateLine(start, end) {
    const dr = end.r - start.r; const dc = end.c - start.c;
    let sr=0, sc=0;
    if (dr===0) { sr=0; sc = dc>0?1:-1; } else if (dc===0) { sr = dr>0?1:-1; sc=0; } else if (dr===dc) { sr = dr>0?1:-1; sc = dc>0?1:-1; } else return null; 
    const line = []; let curr = start;
    while(true) {
      if (!curr.active) return null; line.push(curr);
      if (curr === end) break;
      const next = this.stones.find(s => s.r===curr.r+sr && s.c===curr.c+sc);
      if (!next) return null; curr = next;
    }
    if (line.length > this.maxTake) return null; return line;
  }

  // --- éŠæˆ²æµç¨‹æ§åˆ¶ ---
  saveState() { this.history.push({ stones: this.stones.map(s => ({...s})), turn: this.turn }); }

  confirmMove() {
    if (this.selection.line.length === 0) return;
    this.gameStarted = true; this.saveState(); this.undoCount = 0; 
    // åŸ·è¡Œæ¶ˆé™¤ (Lv2 é™ç´š, Lv1 æ¶ˆå¤±)
    this.selection.line.forEach(s => { if (s.level > 1) { s.level--; s.flash = 20; } else { s.active = false; } });
    this.resetSelection();
    
    // åˆ¤å®šä¸€èˆ¬å‹åˆ©
    if (this.checkWin()) return;
    this.turn = 1 - this.turn;
    // åˆ¤å®šå­¤ç«‹æ£‹å‹åˆ©
    if (this.checkIsolatedWin()) return;
    
    this.draw(); this.updateUI();
    // AI è§¸ç™¼
    if (this.mode !== 'human' && this.turn === 1) { this.state = 'locked'; setTimeout(() => this.runAI(), 600); }
  }

  undo() {
    if (this.history.length === 0 || this.undoCount >= this.MAX_UNDO) return;
    if (this.mode !== 'human' && this.history.length < 2) return;
    const steps = (this.mode !== 'human') ? 2 : 1;
    for(let i=0; i<steps; i++) { if(this.history.length>0) { const s = this.history.pop(); this.restoreState(s); } }
    this.undoCount++; this.state = 'playing'; this.hideBanner(); this.resetSelection(); this.draw(); this.updateUI();
  }
  restoreState(state) { this.stones = state.stones; this.turn = state.turn; this.resize(); }

  // åˆ‡æ›å…ˆå¾Œæ‰‹
  toggleTurn() {
    if (this.gameStarted) return; 
    this.resetSelection(); this.turn = 1 - this.turn; this.updateUI();
    if (this.mode !== 'human' && this.turn === 1) { this.state = 'locked'; setTimeout(() => this.runAI(), 500); }
  }

  surrender() {
    this.state = 'gameover'; this.scores[1 - this.turn]++;
    this.updateScoreDisplay(); this.showBanner('surrender', {loser: this.getPlayerName(this.turn), winner: this.getPlayerName(1 - this.turn)});
    this.disableControls();
  }

  // --- å‹åˆ©åˆ¤å®šé‚è¼¯ ---
  checkWin() {
    if (this.stones.filter(s => s.active).length > 0) return false;
    this.state = 'gameover';
    let winnerIdx = (this.rule === 'lose') ? (1 - this.turn) : this.turn;
    this.scores[winnerIdx]++;
    this.showBanner('win', {winner: this.getPlayerName(winnerIdx)});
    this.updateScoreDisplay(); this.disableControls();
    return true;
  }

  // å­¤ç«‹æ£‹åˆ¤å®š (ç•¶ç›¤é¢æ‰€æœ‰æ£‹å­éƒ½ä¸ç›¸é„°æ™‚)
  checkIsolatedWin() {
    const activeStones = this.stones.filter(s => s.active);
    const dirs = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[-1,-1]];
    const hasNeighbors = activeStones.some(s => dirs.some(d => this.stones.some(n => n.active && n.r === s.r + d[0] && n.c === s.c + d[1])));
    if (hasNeighbors) return false;
    
    // é€²å…¥è‡ªå‹•çµç®—
    this.state = 'gameover';
    let totalHP = 0; activeStones.forEach(s => totalHP += s.level);
    const lastTakerIdx = (totalHP % 2 === 1) ? this.turn : (1 - this.turn);
    const winnerIdx = (this.rule === 'lose') ? (1 - lastTakerIdx) : lastTakerIdx;
    
    this.scores[winnerIdx]++;
    this.draw(); this.updateScoreDisplay();
    this.showBanner('iso', {c: activeStones.length, winner: this.getPlayerName(winnerIdx)});
    this.disableControls(); return true;
  }

  showBanner(type, vars) {
    const overlay = document.getElementById('result-overlay');
    let msg = I18N[currLang][type + '_msg'];
    for (let k in vars) msg = msg.replace(`{${k}}`, vars[k]);
    document.getElementById('res-title').innerText = I18N[currLang][type + '_title'];
    document.getElementById('res-desc').innerText = msg;
    overlay.classList.add('show'); document.getElementById('status').innerText = "";
  }
  hideBanner() { document.getElementById('result-overlay').classList.remove('show'); }

  // --- AI é‚è¼¯ ---
  getAllMoves(stonesState = null) {
    const moves = []; const dirs = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[-1,-1]];
    const currentStones = stonesState || this.stones; const actives = currentStones.filter(s => s.active);
    actives.forEach(start => {
      moves.push([start]); 
      dirs.forEach(d => {
        let line = [start]; let curr = start;
        for (let i = 1; i < this.maxTake; i++) {
          const next = currentStones.find(s => s.active && s.r === curr.r + d[0] && s.c === curr.c + d[1]);
          if (!next) break; curr = next; line.push(next); moves.push([...line]);
        }
      });
    });
    return moves;
  }

  runAI() {
    if (this.state === 'gameover') return;
    const moves = this.getAllMoves();
    let bestMove = null;
    if (this.mode === 'weak') bestMove = moves[Math.floor(Math.random() * moves.length)];
    else {
      // å¼· AI: ä½¿ç”¨ Minimax/Memoization æœç´¢å¿…å‹è·¯å¾‘
      let totalHP = 0; this.stones.forEach(s => { if(s.active) totalHP += s.level; });
      if (totalHP <= 15) { 
        this.memo = new Map(); this.shuffle(moves);
        for (let move of moves) {
              const originalLevels = move.map(s => s.level);
              move.forEach((s, i) => { if (originalLevels[i] === 1) s.active = false; else s.level = 1; });
              let iWin = false;
              if (this.isStateIsolated()) {
                  let remHP = 0; this.stones.forEach(s => { if(s.active) remHP += s.level; });
                  const opponentGetsLast = (remHP % 2 === 1);
                  iWin = (this.rule === 'lose') ? opponentGetsLast : !opponentGetsLast;
              } else { iWin = !this.solveState(); }
              move.forEach((s, i) => { s.level = originalLevels[i]; s.active = true; });
              if (iWin) { bestMove = move; break; }
        }
        if (!bestMove) bestMove = moves[0];
      } else { this.shuffle(moves); bestMove = moves[0]; }
    }
    this.selection.line = bestMove; this.draw();
    setTimeout(() => { this.confirmMove(); if (this.state !== 'gameover') this.state = 'playing'; }, 600);
  }

  solveState() {
    const stateKey = this.stones.map(s => s.active ? s.level : '0').join('');
    if (this.memo.has(stateKey)) return this.memo.get(stateKey);
    let totalHP = 0; this.stones.forEach(s => { if(s.active) totalHP += s.level; });
    if (totalHP === 0) { const result = (this.rule === 'lose'); this.memo.set(stateKey, result); return result; }
    const moves = this.getAllMoves();
    if (moves.length === 0) return (this.rule === 'lose'); 
    for (let move of moves) {
        const originalLevels = move.map(s => s.level);
        move.forEach((s, i) => { if (originalLevels[i] === 1) s.active = false; else s.level = 1; });
        let iWin = false; 
        if (this.isStateIsolated()) {
            let remHP = 0; this.stones.forEach(s => { if(s.active) remHP += s.level; });
            const opponentGetsLast = (remHP % 2 === 1);
            iWin = (this.rule === 'lose') ? opponentGetsLast : !opponentGetsLast;
        } else { iWin = !this.solveState(); }
        move.forEach((s, i) => { s.level = originalLevels[i]; s.active = true; });
        if (iWin) { this.memo.set(stateKey, true); return true; }
    }
    this.memo.set(stateKey, false); return false;
  }
  
  isStateIsolated() {
      const activeStones = this.stones.filter(s => s.active);
      if (activeStones.length === 0) return false; 
      const dirs = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[-1,-1]];
      return !activeStones.some(s => dirs.some(d => this.stones.some(n => n.active && n.r === s.r + d[0] && n.c === s.c + d[1])));
  }

  shuffle(arr) { for (let i = arr.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [arr[i], arr[j]] = [arr[j], arr[i]]; } }
  
  // --- UI æ›´æ–°èˆ‡è¼”åŠ© ---
  updateUI() {
    this.updateScoreDisplay();
    document.getElementById('p1-name').innerText = this.getPlayerName(0);
    document.getElementById('p2-name').innerText = this.getPlayerName(1);
    document.getElementById('rule-hint').innerText = I18N[currLang][this.rule === 'lose' ? 'rule_lose' : 'rule_win'];
    if (this.state !== 'gameover') {
        const isAi = (this.mode !== 'human' && this.turn === 1);
        const txt = isAi ? I18N[currLang].status_ai : I18N[currLang].status_turn.replace('{player}', this.getPlayerName(this.turn));
        const el = document.getElementById('status'); el.innerText = txt; el.style.color = isAi ? '#facc15' : '#f8fafc';
    }
    document.getElementById('p1-score-row').classList.toggle('active', this.turn === 0);
    document.getElementById('p2-score-row').classList.toggle('active', this.turn === 1);
    const hasSel = this.selection.line.length > 0;
    const isMyTurn = (this.state === 'playing') && (this.mode === 'human' || this.turn === 0);
    document.getElementById('btn-confirm').disabled = !(hasSel && isMyTurn);
    document.getElementById('btn-cancel').disabled = !(hasSel && isMyTurn);
    const undoBtn = document.getElementById('btn-undo');
    undoBtn.innerText = I18N[currLang].undo.replace('{n}', this.MAX_UNDO - this.undoCount);
    undoBtn.disabled = !(this.history.length > 0 && this.undoCount < this.MAX_UNDO && isMyTurn);
    document.getElementById('btn-surrender').innerText = I18N[currLang].surrender;
    document.getElementById('btn-surrender').disabled = !isMyTurn;
    const turnBtn = document.getElementById('btn-turn');
    if (this.gameStarted) { turnBtn.classList.add('disabled-visual'); turnBtn.disabled = true; } 
    else { turnBtn.classList.remove('disabled-visual'); turnBtn.disabled = false; }
    turnBtn.innerText = `${I18N[currLang].btn_switch_prefix} [${this.getPlayerName(1 - this.turn)}]`;
  }

  updateScoreDisplay() { document.getElementById('p1-score').innerText = this.scores[0]; document.getElementById('p2-score').innerText = this.scores[1]; }
  
  getPlayerName(idx) {
    if (idx === 0) return (this.mode !== 'human') ? I18N[currLang].name_human : I18N[currLang].name_p1;
    if (this.mode === 'human') return I18N[currLang].name_p2;
    return (this.mode === 'ai') ? I18N[currLang].name_ai_strong : I18N[currLang].name_ai_weak;
  }
  
  resetSelection() { this.selection = { start: null, line: [] }; this.draw(); this.updateUI(); }
  backToMenu() { this.state = 'menu'; document.getElementById('game-view').classList.add('hidden'); document.getElementById('menu-container').classList.remove('hidden'); }
  restart() { this.startNewRound(); }
  disableControls() { document.getElementById('btn-confirm').disabled = true; document.getElementById('btn-cancel').disabled = true; }
}

// å•Ÿå‹•éŠæˆ²
const game = new TriangularNim();
setLang('zh');
</script>
</body>
</html>